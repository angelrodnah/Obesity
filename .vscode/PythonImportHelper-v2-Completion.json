[
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "values",
        "description": "values",
        "isExtraImport": true,
        "detail": "values",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "values",
        "description": "values",
        "isExtraImport": true,
        "detail": "values",
        "documentation": {}
    },
    {
        "label": "pipeline",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "plotly.express",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.express",
        "description": "plotly.express",
        "detail": "plotly.express",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "joblib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "joblib",
        "description": "joblib",
        "detail": "joblib",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "funcs",
        "description": "funcs",
        "isExtraImport": true,
        "detail": "funcs",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "skew",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "kurtosis",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "shapiro",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "iqr",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "kurtosis",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "skew",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "norm",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "uniform",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "BorutaShap",
        "importPath": "BorutaShap",
        "description": "BorutaShap",
        "isExtraImport": true,
        "detail": "BorutaShap",
        "documentation": {}
    },
    {
        "label": "statsmodels.api",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statsmodels.api",
        "description": "statsmodels.api",
        "detail": "statsmodels.api",
        "documentation": {}
    },
    {
        "label": "confusion_matrix",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "confusion_matrix",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "classification_report",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "roc_curve",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "roc_auc_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "roc_curve",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "auc",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "cross_val_predict",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "RandomizedSearchCV",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "StratifiedKFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "cross_val_score",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "KFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "OneVsRestClassifier",
        "importPath": "sklearn.multiclass",
        "description": "sklearn.multiclass",
        "isExtraImport": true,
        "detail": "sklearn.multiclass",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "stats",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "ColumnTransformer",
        "importPath": "sklearn.compose",
        "description": "sklearn.compose",
        "isExtraImport": true,
        "detail": "sklearn.compose",
        "documentation": {}
    },
    {
        "label": "OneHotEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "FunctionTransformer",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "PowerTransformer",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "python_clustering",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "python_clustering",
        "description": "python_clustering",
        "detail": "python_clustering",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "ECOD",
        "importPath": "pyod.models.ecod",
        "description": "pyod.models.ecod",
        "isExtraImport": true,
        "detail": "pyod.models.ecod",
        "documentation": {}
    },
    {
        "label": "GradientBoostingClassifier",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "StackingClassifier",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "XGBClassifier",
        "importPath": "xgboost",
        "description": "xgboost",
        "isExtraImport": true,
        "detail": "xgboost",
        "documentation": {}
    },
    {
        "label": "LGBMClassifier",
        "importPath": "lightgbm",
        "description": "lightgbm",
        "isExtraImport": true,
        "detail": "lightgbm",
        "documentation": {}
    },
    {
        "label": "CatBoostClassifier",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "Feature_Engineering",
        "kind": 2,
        "importPath": "src.app.utils.funcs",
        "description": "src.app.utils.funcs",
        "peekOfCode": "def Feature_Engineering(df):\n        try:\n            df.set_index('id', inplace=True)\n            df['IMC'] = df['Weight'] / (df['Height'] ** 2)\n            df['HA'] = df['FCVC'] * df['NCP']\n            df['UT'] = df['TUE'] / df['Age']\n        except:\n            pass\n        return df\ndef XEncoder(Pipeline,X):",
        "detail": "src.app.utils.funcs",
        "documentation": {}
    },
    {
        "label": "XEncoder",
        "kind": 2,
        "importPath": "src.app.utils.funcs",
        "description": "src.app.utils.funcs",
        "peekOfCode": "def XEncoder(Pipeline,X):\n    categorical_columns = X.columns[X.dtypes==\"object\"].tolist()\n    numeric_columns_to_transform = X.columns[X.dtypes!=\"object\"].tolist()    \n    X_trans = Pipeline.transform(X)\n    transformed_columns = []\n    # Obtener columnas transformadas de OHE\n    if categorical_columns:\n        ohe_columns = Pipeline.named_steps['preprocessor'].named_transformers_['categorical'].named_steps['onehot'].get_feature_names_out()\n        transformed_columns.extend(ohe_columns)\n    # Obtener columnas transformadas de variables numéricas",
        "detail": "src.app.utils.funcs",
        "documentation": {}
    },
    {
        "label": "traduce_columnas",
        "kind": 2,
        "importPath": "src.app.utils.funcs",
        "description": "src.app.utils.funcs",
        "peekOfCode": "def traduce_columnas(df, diccionario):\n    df.columns = [diccionario.get(col, col) for col in df.columns]\n    return df\ndef codifica_columnas(df, diccionario):\n    dff=df.copy(True)\n    for col in dff.columns:\n        if col in diccionario.keys():\n            dff[col] = dff[col].map(diccionario[col])\n    Feature_Engineering(dff)\n    return dff",
        "detail": "src.app.utils.funcs",
        "documentation": {}
    },
    {
        "label": "codifica_columnas",
        "kind": 2,
        "importPath": "src.app.utils.funcs",
        "description": "src.app.utils.funcs",
        "peekOfCode": "def codifica_columnas(df, diccionario):\n    dff=df.copy(True)\n    for col in dff.columns:\n        if col in diccionario.keys():\n            dff[col] = dff[col].map(diccionario[col])\n    Feature_Engineering(dff)\n    return dff\ndef redondea_vars(df):\n    dff=df.copy(deep=True)\n    for var in vars2round:",
        "detail": "src.app.utils.funcs",
        "documentation": {}
    },
    {
        "label": "redondea_vars",
        "kind": 2,
        "importPath": "src.app.utils.funcs",
        "description": "src.app.utils.funcs",
        "peekOfCode": "def redondea_vars(df):\n    dff=df.copy(deep=True)\n    for var in vars2round:\n        dff[var] = dff[var].apply(lambda x: round(x, 0))\n        dff[var] = dff[var].astype(int)\n    return dff",
        "detail": "src.app.utils.funcs",
        "documentation": {}
    },
    {
        "label": "rev_dict",
        "kind": 2,
        "importPath": "src.app.utils.values",
        "description": "src.app.utils.values",
        "peekOfCode": "def rev_dict(diccionario):\n    return {valor: clave for clave, valor in diccionario.items()}\ndiccionario_columnas = {\n    'FAVC': 'Consumo de Alimentos Altos en Calorías',\n    'FCVC': 'Consumo de Verduras',\n    'NCP': 'Número de Comidas Principales',\n    'CAEC': 'Comer Entre Comidas',\n    'CH2O': 'Consumo Diario de Agua',\n    'CALC': 'Consumo de Alcohol',\n    'SCC': 'Monitoreo de Calorías',",
        "detail": "src.app.utils.values",
        "documentation": {}
    },
    {
        "label": "diccionario_columnas",
        "kind": 5,
        "importPath": "src.app.utils.values",
        "description": "src.app.utils.values",
        "peekOfCode": "diccionario_columnas = {\n    'FAVC': 'Consumo de Alimentos Altos en Calorías',\n    'FCVC': 'Consumo de Verduras',\n    'NCP': 'Número de Comidas Principales',\n    'CAEC': 'Comer Entre Comidas',\n    'CH2O': 'Consumo Diario de Agua',\n    'CALC': 'Consumo de Alcohol',\n    'SCC': 'Monitoreo de Calorías',\n    'FAF': 'Frecuencia de Actividad Física',\n    'TUE': 'Uso de Dispositivos Tecnológicos',",
        "detail": "src.app.utils.values",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "src.app.utils.values",
        "description": "src.app.utils.values",
        "peekOfCode": "target = \"NObeyesdad\"\ndecod_target= \"Nivel de obesidad\"\ndict_CAEC={\n    'no': 0,\n    'Sometimes': 1,\n    'Frequently': 2,\n    'Always': 3}\ndict_CALC={\n    'no': 0,\n    'Sometimes': 1,",
        "detail": "src.app.utils.values",
        "documentation": {}
    },
    {
        "label": "dict_var_modelo",
        "kind": 5,
        "importPath": "src.app.utils.values",
        "description": "src.app.utils.values",
        "peekOfCode": "dict_var_modelo = {\n    'Edad': 'Age',\n    'Comer Entre Comidas': 'CAEC',\n    'Consumo de Alcohol': 'CALC',\n    'Consumo Diario de Agua': 'CH2O',\n    'Frecuencia de Actividad Física': 'FAF',\n    'Consumo de Verduras': 'FCVC',\n    'Género': 'Gender_Male',\n    'Hábitos alimienticios': 'HA',\n    'Altura': 'Height',",
        "detail": "src.app.utils.values",
        "documentation": {}
    },
    {
        "label": "variables",
        "kind": 5,
        "importPath": "src.app.utils.values",
        "description": "src.app.utils.values",
        "peekOfCode": "variables = [\n    'Gender',\n    'Age',\n    'Height',\n    'Weight',\n    'family_history_with_overweight',\n    'FAVC',\n    'FCVC',\n    'NCP',\n    'CAEC',",
        "detail": "src.app.utils.values",
        "documentation": {}
    },
    {
        "label": "preguntas",
        "kind": 5,
        "importPath": "src.app.utils.values",
        "description": "src.app.utils.values",
        "peekOfCode": "preguntas = [\n    \"¿Cuál es tu género?\",\n    \"Ingresa tu edad\",\n    \"Ingresa tu altura (m)\",\n    \"Ingresa tu peso (Kg)\",\n    \"¿Tiene un familiar que ha sufrido o sufre de sobrepeso?\",\n    \"¿Consumes alimentos altos en calorías con frecuencia?\",\n    \"¿Sueles comer verduras en tus comidas?\",\n    \"¿Cuántas comidas principales tienes al día?\",\n    \"¿Comes algo entre comidas?\",",
        "detail": "src.app.utils.values",
        "documentation": {}
    },
    {
        "label": "opciones_respuesta",
        "kind": 5,
        "importPath": "src.app.utils.values",
        "description": "src.app.utils.values",
        "peekOfCode": "opciones_respuesta = [\n    [\"Femenino\", \"Masculino\"],\n    \"-\",\n    \"-\",\n    \"-\",\n    [\"No\", \"Sí\"],\n    [\"No\", \"Sí\"],\n    [\"Nunca\", \"A veces\", \"Siempre\"],\n    [\"Una\", \"Dos\", \"Tres\", \"Más de tres\"],\n    [\"No\", \"A veces\", \"Frecuentemente\", \"Siempre\"],",
        "detail": "src.app.utils.values",
        "documentation": {}
    },
    {
        "label": "opciones_respuesta",
        "kind": 5,
        "importPath": "src.app.utils.values",
        "description": "src.app.utils.values",
        "peekOfCode": "opciones_respuesta = [[option] if not isinstance(option, list) else option for option in opciones_respuesta]\ndf2= pd.DataFrame({\n    'Columna': variables,\n    'Pregunta': preguntas,\n    'Opciones de Respuesta': opciones_respuesta\n})\nvar_values={\n'FCVC':[1,2,3],\n'NCP':[1,2,3,4],\n'CH2O':[1,2,3],",
        "detail": "src.app.utils.values",
        "documentation": {}
    },
    {
        "label": "dicts",
        "kind": 5,
        "importPath": "src.app.utils.values",
        "description": "src.app.utils.values",
        "peekOfCode": "dicts = {}\nfor a, b, c in zip(\n    df2.loc[df2.Columna.isin(list(var_values.keys())), 'Columna'],\n    df2.loc[df2.Columna.isin(list(var_values.keys())), 'Opciones de Respuesta'],\n    df2.loc[df2.Columna.isin(list(var_values.keys())), 'Columna'].apply(lambda x: var_values[x])\n):\n    dicts[a] = dict(zip(b, c))\ndicts['Gender']=rev_dict(dict_gender)\ndicts['MTRANS']=rev_dict(dict_mtrans)\ncols_y_n=['family_history_with_overweight','FAVC','SMOKE','SCC']",
        "detail": "src.app.utils.values",
        "documentation": {}
    },
    {
        "label": "revdicts",
        "kind": 5,
        "importPath": "src.app.utils.values",
        "description": "src.app.utils.values",
        "peekOfCode": "revdicts = {}\nfor a, b, c in zip(\n    df2.loc[df2.Columna.isin(list(var_values.keys())), 'Columna'],\n    df2.loc[df2.Columna.isin(list(var_values.keys())), 'Opciones de Respuesta'],\n    df2.loc[df2.Columna.isin(list(var_values.keys())), 'Columna'].apply(lambda x: var_values[x])\n):\n    revdicts[a] = dict(zip(c, b))\nrevdicts['Gender']=dict_gender\nrevdicts['MTRANS']=dict_mtrans\ncols_y_n=['family_history_with_overweight','FAVC','SMOKE','SCC']",
        "detail": "src.app.utils.values",
        "documentation": {}
    },
    {
        "label": "vars2round",
        "kind": 5,
        "importPath": "src.app.utils.values",
        "description": "src.app.utils.values",
        "peekOfCode": "vars2round = [ 'Age',\n                    'FCVC',\n                    'NCP',\n                    'CAEC',\n                    'CH2O',\n                    'FAF',\n                    'TUE',\n                    'CALC']",
        "detail": "src.app.utils.values",
        "documentation": {}
    },
    {
        "label": "grafico_cruzado",
        "kind": 2,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "def grafico_cruzado(data, columna_objetivo, columna_categorica, categorias):\n    fig3 = px.histogram(\n        data[data[columna_objetivo].isin(categorias)],\n        x=columna_objetivo,\n        color=columna_categorica,\n        barmode='group',\n        category_orders={columna_categorica: categorias},\n    )\n    tab_graficos.plotly_chart(fig3, use_container_width=True)\ncolumnas_categoricas = ['Género', ",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "imagen2",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "imagen2 = Image.open('./img/Obesity.webp')\nst.set_page_config(page_title=\"Conoce tu riesgo de obesidad :question:\", layout=\"wide\")\nst.header(\":blue[Tus hábitos: ]:pizza: :hamburger: :hotdog: :cake: :arrow_right::arrow_right::arrow_right: :red[:heartbeat: ¿No estarás en riesgo de obesidad?]  :heartbeat:  :skull:\")\ntab_inicio, tab_conjunto_datos, tab_graficos, tab_modelo = st.tabs([\"Inicio\", \"Sobre el Conjunto de Datos\", \"Gráficos\", \"Predicción del Nivel de Obesidad\"])\n# TAB INICIO\ninf, video = tab_inicio.columns(2, gap=\"large\")\ninf.markdown(\"El objetivo principal de este proyecto es desarrollar un modelo predictivo que pueda anticipar la probabilidad de que un individuo se vuelva obeso basándose en un análisis de datos exhaustivo. \\\n            La obesidad está asociada con una serie de resultados adversos, incluido un mayor riesgo de enfermedades cardiovasculares, diabetes tipo 2, problemas respiratorios y articulares. \\\n            Además, puede afectar la salud mental, lo que lleva a un aumento de las tasas de depresión y ansiedad. Por eso, abordar y prevenir la obesidad es vital para la salud y el bienestar en general.\")\ninf.markdown(\"Usando el conjunto de datos, que abarca variables cruciales como antecedentes familiares de sobrepeso, hábitos alimenticios (incluido el consumo frecuente de alimentos altos en calorías,\\",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "video_file",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "video_file = open('./video/Obesidad_ Un grave problema de salud pública.mp4', 'rb')\nvideo_bytes = video_file.read()\nvideo.video(video_bytes)\n# TAB CONJUNTO DE DATOS\ntab_conjunto_datos.subheader(\"Sobre el Conjunto de Datos\")\ncolumn_inf, column_conjunto_datos  = tab_conjunto_datos.columns(2, gap=\"large\")\ncolumn_conjunto_datos.image(imagen2, width=100, use_column_width=True, clamp=False, channels='RGB', output_format='auto')\ncolumn_inf.subheader(\"Conjunto de Datos\")\ncolumn_conjunto_datos.subheader(\"Preguntas de la encuesta utilizada para la recopilación inicial de información\")\ncolumn_inf.markdown(",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "video_bytes",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "video_bytes = video_file.read()\nvideo.video(video_bytes)\n# TAB CONJUNTO DE DATOS\ntab_conjunto_datos.subheader(\"Sobre el Conjunto de Datos\")\ncolumn_inf, column_conjunto_datos  = tab_conjunto_datos.columns(2, gap=\"large\")\ncolumn_conjunto_datos.image(imagen2, width=100, use_column_width=True, clamp=False, channels='RGB', output_format='auto')\ncolumn_inf.subheader(\"Conjunto de Datos\")\ncolumn_conjunto_datos.subheader(\"Preguntas de la encuesta utilizada para la recopilación inicial de información\")\ncolumn_inf.markdown(\n    \"\"\"",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "columnas_numericas",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "columnas_numericas = [ 'Edad', 'Altura', 'Peso', \"Indice de Masa Corporal\"]\ncolumnas_numericas_seleccionadas = tab_graficos.multiselect(label=\"Selecciona columnas numéricas\", options=columnas_numericas[0:], default=columnas_numericas[0:])\nfor col in columnas_numericas_seleccionadas:\n    fig1 = px.histogram(dff, x=col, marginal=\"box\", color=\"Género\")\n    fig1.update_layout(template='plotly_dark', title_x=0.5, yaxis_title='Cuenta', xaxis_title=f\"{col}\", title=f\"Distribución de {col}\")\n    tab_graficos.plotly_chart(fig1, use_container_width=True)\n## Gráfico 2\ntab_graficos.subheader(\"Correlación entre Altura y Peso\")\nfig2 = px.scatter(data_frame=dff,y=\"Altura\",x=\"Peso\",size=\"Indice de Masa Corporal\",color=\"Género\",trendline=\"ols\")\nfig2.update_layout(template='plotly_dark')",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "columnas_numericas_seleccionadas",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "columnas_numericas_seleccionadas = tab_graficos.multiselect(label=\"Selecciona columnas numéricas\", options=columnas_numericas[0:], default=columnas_numericas[0:])\nfor col in columnas_numericas_seleccionadas:\n    fig1 = px.histogram(dff, x=col, marginal=\"box\", color=\"Género\")\n    fig1.update_layout(template='plotly_dark', title_x=0.5, yaxis_title='Cuenta', xaxis_title=f\"{col}\", title=f\"Distribución de {col}\")\n    tab_graficos.plotly_chart(fig1, use_container_width=True)\n## Gráfico 2\ntab_graficos.subheader(\"Correlación entre Altura y Peso\")\nfig2 = px.scatter(data_frame=dff,y=\"Altura\",x=\"Peso\",size=\"Indice de Masa Corporal\",color=\"Género\",trendline=\"ols\")\nfig2.update_layout(template='plotly_dark')\ntab_graficos.plotly_chart(fig2, use_container_width=True)",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "fig2",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "fig2 = px.scatter(data_frame=dff,y=\"Altura\",x=\"Peso\",size=\"Indice de Masa Corporal\",color=\"Género\",trendline=\"ols\")\nfig2.update_layout(template='plotly_dark')\ntab_graficos.plotly_chart(fig2, use_container_width=True)\n## Gráfico 3\ndef grafico_cruzado(data, columna_objetivo, columna_categorica, categorias):\n    fig3 = px.histogram(\n        data[data[columna_objetivo].isin(categorias)],\n        x=columna_objetivo,\n        color=columna_categorica,\n        barmode='group',",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "columnas_categoricas",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "columnas_categoricas = ['Género', \n                        'Frecuencia de Actividad Física',\n                        'Consumo de Alimentos Altos en Calorías',\n                        'Consumo de Verduras',\n                        'Número de Comidas Principales',\n                        'Comer Entre Comidas',\n                        'Fumar',\n                        'Consumo Diario de Agua',\n                        'Monitoreo de Calorías',\n                        'Consumo de Alcohol',",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "columna_categorica_seleccionada",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "columna_categorica_seleccionada = tab_graficos.multiselect(label=\"Selecciona una variable\", options=columnas_categoricas, default=[\"Género\"])\ncategorias = [\"Peso Insuficiente\", \"Peso Normal\", \"Nivel de Sobrepeso I\", \"Nivel de Sobrepeso II\", \"Obesidad Tipo I\", \"Obesidad Tipo II\", \"Obesidad Tipo III\"]\nif columna_categorica_seleccionada:\n    tab_graficos.subheader(f\"Distribución de Niveles de Obesidad por {columna_categorica_seleccionada[0]}\")\ngrafico_cruzado(dff, \"Nivel de Obesidad\", columna_categorica_seleccionada[0], categorias)\n## Gráfico 4\ntab_graficos.subheader(\"Frecuencia de Actividad Física por Nivel de Obesidad\")\nfig4 = px.box(dff, x=\"Nivel de Obesidad\", y=\"Frecuencia de Actividad Física\", points=\"all\")\ntab_graficos.plotly_chart(fig4, use_container_width=True)\n## Gráfico 5",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "categorias",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "categorias = [\"Peso Insuficiente\", \"Peso Normal\", \"Nivel de Sobrepeso I\", \"Nivel de Sobrepeso II\", \"Obesidad Tipo I\", \"Obesidad Tipo II\", \"Obesidad Tipo III\"]\nif columna_categorica_seleccionada:\n    tab_graficos.subheader(f\"Distribución de Niveles de Obesidad por {columna_categorica_seleccionada[0]}\")\ngrafico_cruzado(dff, \"Nivel de Obesidad\", columna_categorica_seleccionada[0], categorias)\n## Gráfico 4\ntab_graficos.subheader(\"Frecuencia de Actividad Física por Nivel de Obesidad\")\nfig4 = px.box(dff, x=\"Nivel de Obesidad\", y=\"Frecuencia de Actividad Física\", points=\"all\")\ntab_graficos.plotly_chart(fig4, use_container_width=True)\n## Gráfico 5\ntab_graficos.subheader(\"Gráfico de Dispersión de Edad e IMC\")",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "fig4",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "fig4 = px.box(dff, x=\"Nivel de Obesidad\", y=\"Frecuencia de Actividad Física\", points=\"all\")\ntab_graficos.plotly_chart(fig4, use_container_width=True)\n## Gráfico 5\ntab_graficos.subheader(\"Gráfico de Dispersión de Edad e IMC\")\nfig5 = px.scatter(dff, x=\"Edad\", y=\"Indice de Masa Corporal\", color=\"Nivel de Obesidad\")\ntab_graficos.plotly_chart(fig5, use_container_width=True)\n## Gráfico 6\ntab_graficos.subheader(\"Comparación de IMC Basada en Género y Preferencia de Transporte\")\ntransporte_seleccionado = tab_graficos.multiselect(label=\"Selecciona un tipo de transporte\", options=dff['Preferencia de Transporte'].unique() ,default=[\"Transporte Público\"])\ndf_filtrado = dff[dff['Preferencia de Transporte'].isin(transporte_seleccionado)]",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "fig5",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "fig5 = px.scatter(dff, x=\"Edad\", y=\"Indice de Masa Corporal\", color=\"Nivel de Obesidad\")\ntab_graficos.plotly_chart(fig5, use_container_width=True)\n## Gráfico 6\ntab_graficos.subheader(\"Comparación de IMC Basada en Género y Preferencia de Transporte\")\ntransporte_seleccionado = tab_graficos.multiselect(label=\"Selecciona un tipo de transporte\", options=dff['Preferencia de Transporte'].unique() ,default=[\"Transporte Público\"])\ndf_filtrado = dff[dff['Preferencia de Transporte'].isin(transporte_seleccionado)]\nfig6 = px.bar(\n    df_filtrado,\n    x=\"Nivel de Obesidad\",\n    y=\"Indice de Masa Corporal\",",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "transporte_seleccionado",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "transporte_seleccionado = tab_graficos.multiselect(label=\"Selecciona un tipo de transporte\", options=dff['Preferencia de Transporte'].unique() ,default=[\"Transporte Público\"])\ndf_filtrado = dff[dff['Preferencia de Transporte'].isin(transporte_seleccionado)]\nfig6 = px.bar(\n    df_filtrado,\n    x=\"Nivel de Obesidad\",\n    y=\"Indice de Masa Corporal\",\n    color=\"Género\",\n    facet_col=\"Preferencia de Transporte\",\n)\ntab_graficos.plotly_chart(fig6, use_container_width=True)",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "df_filtrado",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "df_filtrado = dff[dff['Preferencia de Transporte'].isin(transporte_seleccionado)]\nfig6 = px.bar(\n    df_filtrado,\n    x=\"Nivel de Obesidad\",\n    y=\"Indice de Masa Corporal\",\n    color=\"Género\",\n    facet_col=\"Preferencia de Transporte\",\n)\ntab_graficos.plotly_chart(fig6, use_container_width=True)\n# TAB MODELO",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "fig6",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "fig6 = px.bar(\n    df_filtrado,\n    x=\"Nivel de Obesidad\",\n    y=\"Indice de Masa Corporal\",\n    color=\"Género\",\n    facet_col=\"Preferencia de Transporte\",\n)\ntab_graficos.plotly_chart(fig6, use_container_width=True)\n# TAB MODELO\ntab_modelo.subheader(\"Modelo de Clasificación de Nivel de Obesidad\")",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "columnas",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "columnas = list(dict_var_modelo)\n#columnas_seleccionadas = tab_modelo.multiselect(label=\"Selecciona columnas\", options=columnas[0:], default=columnas[0:])\n# Página de inicio de presentación\ntab_modelo.markdown(\"## Bienvenido a Conoce Tu Obesidad\")\ntab_modelo.markdown(\"Esta aplicación te ayudará a determinar tu riesgo de obesidad.\")\ntab_modelo.markdown(\"Por favor, ingresa la siguiente información:\")\n# Crear un diccionario para almacenar las respuestas\nrespuestas = {}\n# Dividir la página en dos columnas\ncol1, col2 = tab_modelo.columns(2)",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "#columnas_seleccionadas",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "#columnas_seleccionadas = tab_modelo.multiselect(label=\"Selecciona columnas\", options=columnas[0:], default=columnas[0:])\n# Página de inicio de presentación\ntab_modelo.markdown(\"## Bienvenido a Conoce Tu Obesidad\")\ntab_modelo.markdown(\"Esta aplicación te ayudará a determinar tu riesgo de obesidad.\")\ntab_modelo.markdown(\"Por favor, ingresa la siguiente información:\")\n# Crear un diccionario para almacenar las respuestas\nrespuestas = {}\n# Dividir la página en dos columnas\ncol1, col2 = tab_modelo.columns(2)\n# Calcular la mitad del número total de preguntas",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "respuestas",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "respuestas = {}\n# Dividir la página en dos columnas\ncol1, col2 = tab_modelo.columns(2)\n# Calcular la mitad del número total de preguntas\nmitad_preguntas = len(preguntas) // 2\n# Mostrar los selectbox y campos de entrada en dos columnas\nfor i, pregunta in enumerate(preguntas):\n    # Determinar en qué columna mostrar la pregunta\n    if i < mitad_preguntas:\n        columna = col1",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "mitad_preguntas",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "mitad_preguntas = len(preguntas) // 2\n# Mostrar los selectbox y campos de entrada en dos columnas\nfor i, pregunta in enumerate(preguntas):\n    # Determinar en qué columna mostrar la pregunta\n    if i < mitad_preguntas:\n        columna = col1\n    else:\n        columna = col2\n    # Si la variable es 'Age', utilizar un intslider\n    if variables[i] in ['Age', 'Height', 'Weight']:",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "data_report",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def data_report(df):\n    # Sacamos los NOMBRES\n    cols = pd.DataFrame(df.columns.values, columns=[\"COL_N\"])\n    # Sacamos los TIPOS\n    types = pd.DataFrame(df.dtypes.values, columns=[\"DATA_TYPE\"])\n    # Sacamos los MISSINGS\n    percent_missing = round(df.isnull().sum() * 100 / len(df), 2)\n    percent_missing_df = pd.DataFrame(percent_missing.values, columns=[\"MISSINGS (%)\"])\n    # Sacamos los VALORES UNICOS\n    unicos = pd.DataFrame(df.nunique().values, columns=[\"UNIQUE_VALUES\"])",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "drop_cols",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def drop_cols(df_, max_cardi=20, max_miss=30):\n    df = df_.copy()\n    delete_col = []\n    for i in df.columns:\n        missings = df[i].isnull().sum() * 100 / len(df)\n        # Elimina por missings\n        if missings >= max_miss:\n            df.drop(i, 1, inplace=True)\n            continue\n        # Elimina por cardinalidad en variables categoricas",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "outliers_quantile",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def outliers_quantile(df, feature, param=1.5):  \n    iqr_ = iqr(df[feature], nan_policy='omit')\n    q1 = np.nanpercentile(df[feature], 25)\n    q3 = np.nanpercentile(df[feature], 75)\n    th1 = q1 - iqr_*param\n    th2 = q3 + iqr_*param\n    return df[(df[feature] >= th1) & (df[feature] <= th2)].reset_index(drop=True)\ndef outlier_meanSd(df, feature, param=3):   \n    media = df[feature].mean()\n    desEst = df[feature].std()",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "outlier_meanSd",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def outlier_meanSd(df, feature, param=3):   \n    media = df[feature].mean()\n    desEst = df[feature].std()\n    th1 = media - desEst*param\n    th2 = media + desEst*param\n    return df[((df[feature] >= th1) & (df[feature] <= th2))  | (df[feature].isnull())].reset_index(drop=True)\ndef plot_tidy_categorical(df, sel_cols, target, file_output=None):\n    \"\"\"\n    Generate bar plots for each categorical variable,\n    grouped by target variable.",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_tidy_categorical",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_tidy_categorical(df, sel_cols, target, file_output=None):\n    \"\"\"\n    Generate bar plots for each categorical variable,\n    grouped by target variable.\n    Parameters:\n    - df: DataFrame, the input dataset\n    - sel_cols: list, categorical variables\n    - target: str, name of the column containing the target variable\n    Returns:\n    - None (displays the plots)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_tidy",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_tidy(df, sel_cols, target,file_output=None):\n    \"\"\"\n    Generate kernel density estimation (KDE) plots for each variable,\n    grouped by target variable.\n    Parameters:\n    - df: DataFrame, the input dataset\n    - sel_cols: list, variables used for clustering\n    - target: str, name of the column containing the target variable\n    Returns:\n    - None (displays the plots)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "reduce_memory_usage",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def reduce_memory_usage(df, verbose=True):\n    numerics = [\"int8\", \"int16\", \"int32\", \"int64\", \"float16\", \"float32\", \"float64\"]\n    start_mem = df.memory_usage().sum() / 1024 ** 2\n    # Excluir las columnas de índice\n    columns_to_exclude = df.index.names if df.index.name else []\n    for col in df.columns:\n        if col in columns_to_exclude:\n            continue\n        col_type = df[col].dtypes\n        if col_type in numerics:",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_kde_histogram_with_stats",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_kde_histogram_with_stats(data, column_name, title, ax=None):\n    # Use provided ax or create a new subplot\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(10, 6))\n    # KDE + Histogram\n    sns.distplot(data[column_name],fit=norm, kde=True, rug=True, ax=ax)\n    ax.set_title(f'KDE + Histogram - {title}')\n    # Verificar si la columna contiene datos numéricos\n    if pd.api.types.is_numeric_dtype(data[column_name].dtype):\n        # Calcular estadísticas solo si la columna contiene datos numéricos",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "box_violin_plot",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def box_violin_plot(data, column, title, ax=None):\n    # Use provided ax or create a new subplot\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(8, 4))\n    # Violin + Boxplot\n    sns.violinplot(data=data, x=column, inner='point', linewidth=0, saturation=0.4, orient='h', ax=ax)\n    sns.boxplot(x=column, data=data, width=0.3, boxprops={'zorder': 2}, ax=ax, orient='h', fliersize=5)\n    # Adjust the plot design\n    ax.set_title(f\"Boxplot + Violin Plot - {title}\")\n    # Get statistics",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "qq_plot",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def qq_plot(data, column_name, title,ax=None):\n    if ax is None:\n        _, ax = plt.subplots(figsize=(8, 4))\n    # Create QQ plot\n    sm.qqplot(data[column_name], line='s', ax=ax)\n    ax.set_title(f\"Quantile-Quantile Plot - {title}\")\n    plt.xlabel(\"Cuantiles teóricos\")\n    plt.ylabel(\"Cuantiles observados\")\ndef plot_distribucion(data, column_name, **kwargs):\n    title = kwargs.get('title', column_name)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_distribucion",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_distribucion(data, column_name, **kwargs):\n    title = kwargs.get('title', column_name)\n    save_png, filename = kwargs.get('save_png', False), kwargs.get('filename', 'tmp.png')\n    # Create subplots with specified width ratios\n    fig, axs = plt.subplots(1, 3, figsize=(15, 6), gridspec_kw={'width_ratios': [2, 2, 1]})\n    # Loop through the plots and functions\n    for i, plot_function in enumerate([plot_kde_histogram_with_stats, box_violin_plot, qq_plot]):\n        plot_function(data, column_name, title, ax=axs[i])\n    # Adjust the layout of the subplots\n    plt.tight_layout()",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "sim_curtosis",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def sim_curtosis(data, column_name):\n    kurtosis_valor = kurtosis(data[column_name])\n    skewness_valor = skew(data[column_name])\n    if kurtosis_valor > 3:\n        kurtosis_=\"La distribución es leptocúrtica, lo que sugiere colas pesadas y picos agudos.\"\n    elif kurtosis_valor < 3:\n        kurtosis_=\"La distribución es platicúrtica, lo que sugiere colas ligeras y un pico achatado.\"\n    else:\n        kurtosis_=\"La distribución es mesocúrtica, similar a una distribución normal.\"\n    if skewness_valor > 0:",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_horizontal_catplot",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_horizontal_catplot(df, catcols, diccionario_columnas=None, diccionario_valores=None,\n                            save_png=False, filename='tmp.png'):\n    \"\"\"\n    Genera gráficos Seaborn para la frecuencia de valores únicos en las columnas categóricas del DataFrame.\n    Los gráficos se organizan en filas y las categorías se ordenan por porcentaje descendente.\n    El número de valores NaN o nulos se muestra en el título de cada gráfico.\n    Parameters:\n    - df: DataFrame de pandas\n    - catcols: Lista de columnas categóricas\n    - diccionario_columnas: Diccionario para decodificar nombres de columnas (opcional)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_analysis",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_analysis(data, target, col):\n    col_mean = []\n    for each in data[target].unique():\n        x = data[data[target] == each]\n        mean = x[col].mean()\n        col_mean.append(mean)\n    plt.figure(figsize=(8,6))\n    plt.subplot(2,2,1)\n    plt.hist(data[col], color=\"lightgreen\")\n    plt.xlabel(col)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "sqrt_transform",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def sqrt_transform(X):\n    return np.sqrt(X)\ndef log_transform(X):\n    return np.log1p(X)\ndef classify_distributions(df, threshold=0.05):\n    \"\"\"\n    Clasifica las distribuciones de las columnas numéricas del DataFrame en una de las siguientes categorías:\n    - 'normal': si la distribución se ajusta a una distribución normal según el test de Shapiro-Wilk.\n    - 'positive_increasing': si la distribución es estrictamente creciente positiva.\n    - 'positive_decreasing': si la distribución es estrictamente decreciente positiva.",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "log_transform",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def log_transform(X):\n    return np.log1p(X)\ndef classify_distributions(df, threshold=0.05):\n    \"\"\"\n    Clasifica las distribuciones de las columnas numéricas del DataFrame en una de las siguientes categorías:\n    - 'normal': si la distribución se ajusta a una distribución normal según el test de Shapiro-Wilk.\n    - 'positive_increasing': si la distribución es estrictamente creciente positiva.\n    - 'positive_decreasing': si la distribución es estrictamente decreciente positiva.\n    - 'rectangular': si la distribución es rectangular.\n    - 'skewed_left': si la distribución tiene sesgo a la izquierda.",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "classify_distributions",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def classify_distributions(df, threshold=0.05):\n    \"\"\"\n    Clasifica las distribuciones de las columnas numéricas del DataFrame en una de las siguientes categorías:\n    - 'normal': si la distribución se ajusta a una distribución normal según el test de Shapiro-Wilk.\n    - 'positive_increasing': si la distribución es estrictamente creciente positiva.\n    - 'positive_decreasing': si la distribución es estrictamente decreciente positiva.\n    - 'rectangular': si la distribución es rectangular.\n    - 'skewed_left': si la distribución tiene sesgo a la izquierda.\n    - 'skewed_right': si la distribución tiene sesgo a la derecha.\n    - 'bimodal': si la distribución tiene dos modas.",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "selvars_boruta",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def selvars_boruta(data,ytarget,isclass=True,n_trials=100):\n    Feature_Selector = BorutaShap(importance_measure='shap',\n                                classification=isclass)\n    Feature_Selector.fit(X=data, y=ytarget, n_trials=n_trials, random_state=0)\n    Feature_Selector.TentativeRoughFix()\n    Feature_Selector.plot(X_size=8, figsize=(20,8),\n                y_scale='log', which_features='all')\n    selvars=sorted(list(Feature_Selector.Subset().columns))\n    return selvars\nimport seaborn as sns",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_confusion_matrix",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_confusion_matrix(true_labels, predicted_labels):\n    \"\"\"\n    Plot a confusion matrix using true labels and predicted labels.\n    Parameters:\n    true_labels (array-like): True labels.\n    predicted_labels (array-like): Predicted labels.\n    \"\"\"\n    # Calculate the confusion matrix\n    conf_matrix = confusion_matrix(true_labels, predicted_labels)\n    # Create a heatmap using seaborn",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "cross_validation_with_confusion_matrix",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def cross_validation_with_confusion_matrix(estimator, X, y, nsplits=10):\n    cv = StratifiedKFold(n_splits=nsplits)\n    # Perform cross-validation\n    predicted = cross_val_predict(estimator, X, y, cv=cv)\n    # Calculate confusion matrix and classification report for each fold\n    for i, (train_idx, test_idx) in enumerate(cv.split(X, y)):\n        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]\n        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]\n        # Fit the estimator on training data\n        estimator.fit(X_train, y_train)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_roc_curve",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_roc_curve(model, X_val, y_val):\n    # Predecir las probabilidades de las clases positivas\n    y_prob = model.predict_proba(X_val)[:, 1]\n    # Calcular la tasa de verdaderos positivos (TPR) y la tasa de falsos positivos (FPR)\n    fpr, tpr, thresholds = roc_curve(y_val, y_prob)\n    # Calcular el área bajo la curva ROC (AUC)\n    auc = roc_auc_score(y_val, y_prob)\n    # Plotear la curva ROC\n    plt.figure(figsize=(8, 6))\n    plt.plot(fpr, tpr, label=f'AUC = {auc:.2f}')",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "generate_roc_auc",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def generate_roc_auc(estimator, X_train, y_train, X_val, y_val):\n    \"\"\"\n    Generate ROC curve and calculate AUC using one-vs-all technique.\n    Parameters:\n    estimator: scikit-learn estimator object\n        The classifier or regressor to use.\n    X_train: array-like, shape (n_samples, n_features)\n        The input samples for training.\n    y_train: array-like, shape (n_samples,)\n        The target values for training.",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "hyperparameter_tuning",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def hyperparameter_tuning(models, X, y, scoring='accuracy'):\n    # Almacena los resultados en un DataFrame\n    results = []\n    # Loop sobre los modelos con tqdm para mostrar una barra de progreso\n    for model_name, config in tqdm(models.items(), desc=\"Hyperparameter Tuning\"):\n        model = RandomizedSearchCV(config[\"model\"], config[\"params\"], n_iter=50, cv=5, scoring=scoring,\n                                   random_state=42)\n        model.fit(X, y)  # Ajusta el modelo con los datos de entrenamiento\n        best_params = model.best_params_\n        best_score = model.best_score_",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "perform_cross_validation",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def perform_cross_validation(models, x_train, y_train, n_splits=8, random_state=42, metric='accuracy'):\n    kfold = StratifiedKFold(n_splits=n_splits, shuffle=True, random_state=random_state)\n    cv_results = []\n    for name, model in models.items():\n        cv_scores = cross_val_score(model, x_train, y_train, scoring=metric, cv=kfold, n_jobs=-1)\n        cv_results.append(np.mean(cv_scores))\n    cv_df = pd.DataFrame({\"CrossVal_Score_Means\": cv_results, \"Algorithm\": list(models.keys())})\n    plt.figure(figsize=(10, 7))\n    g = sns.barplot(x=\"CrossVal_Score_Means\", y=\"Algorithm\", data=cv_df, orient=\"h\", palette='cool', \n                    edgecolor=\"black\", linewidth=1)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "test_distribution_cv",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def test_distribution_cv(dataframe, perfrac=0.01, columns=None, n_trials=10):\n    sample = dataframe.sample(frac=perfrac)\n    kf = KFold(n_splits=n_trials, shuffle=True, random_state=42)\n    results = []\n    if columns is None:\n        columns = dataframe.columns\n    for column_name in columns:\n        equal_distributions = 0\n        for train_index, test_index in kf.split(dataframe):\n            train_data = dataframe.iloc[train_index]",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_input_columns_pipeline",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def get_input_columns_pipeline(pipeline):\n    input_columns = []\n    column_transformer=pipeline.named_steps['preprocessor']   \n    # Iterar sobre las transformaciones dentro del ColumnTransformer\n    for _, _, columns in column_transformer.transformers_:\n        # Si el transformer es 'passthrough', agregar las columnas originales\n        if columns == 'passthrough':\n            input_columns.extend(columns)\n        else:\n            input_columns.extend(columns)",
        "detail": "src.utils.utils",
        "documentation": {}
    }
]