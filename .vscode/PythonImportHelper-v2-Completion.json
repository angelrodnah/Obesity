[
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "SimpleImputer",
        "importPath": "sklearn.impute",
        "description": "sklearn.impute",
        "isExtraImport": true,
        "detail": "sklearn.impute",
        "documentation": {}
    },
    {
        "label": "OneHotEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "RobustScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "LabelBinarizer",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "OrdinalEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "FunctionTransformer",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "OneHotEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "FunctionTransformer",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "PowerTransformer",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "ColumnTransformer",
        "importPath": "sklearn.compose",
        "description": "sklearn.compose",
        "isExtraImport": true,
        "detail": "sklearn.compose",
        "documentation": {}
    },
    {
        "label": "ColumnTransformer",
        "importPath": "sklearn.compose",
        "description": "sklearn.compose",
        "isExtraImport": true,
        "detail": "sklearn.compose",
        "documentation": {}
    },
    {
        "label": "ColumnTransformer",
        "importPath": "sklearn.compose",
        "description": "sklearn.compose",
        "isExtraImport": true,
        "detail": "sklearn.compose",
        "documentation": {}
    },
    {
        "label": "FeatureUnion",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "confloat",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "constr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "custom_calculus",
        "importPath": "src.obesity_etl_functions",
        "description": "src.obesity_etl_functions",
        "isExtraImport": true,
        "detail": "src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "load_clean_transform",
        "importPath": "src.obesity_etl_functions",
        "description": "src.obesity_etl_functions",
        "isExtraImport": true,
        "detail": "src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "calc_age_range",
        "importPath": "src.obesity_etl_functions",
        "description": "src.obesity_etl_functions",
        "isExtraImport": true,
        "detail": "src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "generate_kmodes_clusters",
        "importPath": "src.obesity_kmodes_functions",
        "description": "src.obesity_kmodes_functions",
        "isExtraImport": true,
        "detail": "src.obesity_kmodes_functions",
        "documentation": {}
    },
    {
        "label": "src.data_common_functions",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "src.data_common_functions",
        "description": "src.data_common_functions",
        "detail": "src.data_common_functions",
        "documentation": {}
    },
    {
        "label": "select_data",
        "importPath": "src.data_common_functions",
        "description": "src.data_common_functions",
        "isExtraImport": true,
        "detail": "src.data_common_functions",
        "documentation": {}
    },
    {
        "label": "read_file",
        "importPath": "src.data_common_functions",
        "description": "src.data_common_functions",
        "isExtraImport": true,
        "detail": "src.data_common_functions",
        "documentation": {}
    },
    {
        "label": "select_data",
        "importPath": "src.data_common_functions",
        "description": "src.data_common_functions",
        "isExtraImport": true,
        "detail": "src.data_common_functions",
        "documentation": {}
    },
    {
        "label": "CURRENT_DIR",
        "importPath": "src.bd",
        "description": "src.bd",
        "isExtraImport": true,
        "detail": "src.bd",
        "documentation": {}
    },
    {
        "label": "URL_DB",
        "importPath": "src.bd",
        "description": "src.bd",
        "isExtraImport": true,
        "detail": "src.bd",
        "documentation": {}
    },
    {
        "label": "open_connection",
        "importPath": "src.bd",
        "description": "src.bd",
        "isExtraImport": true,
        "detail": "src.bd",
        "documentation": {}
    },
    {
        "label": "close_connection",
        "importPath": "src.bd",
        "description": "src.bd",
        "isExtraImport": true,
        "detail": "src.bd",
        "documentation": {}
    },
    {
        "label": "exec_query_result",
        "importPath": "src.bd",
        "description": "src.bd",
        "isExtraImport": true,
        "detail": "src.bd",
        "documentation": {}
    },
    {
        "label": "exec_query",
        "importPath": "src.bd",
        "description": "src.bd",
        "isExtraImport": true,
        "detail": "src.bd",
        "documentation": {}
    },
    {
        "label": "CURRENT_DIR",
        "importPath": "src.bd",
        "description": "src.bd",
        "isExtraImport": true,
        "detail": "src.bd",
        "documentation": {}
    },
    {
        "label": "KModes",
        "importPath": "kmodes.kmodes",
        "description": "kmodes.kmodes",
        "isExtraImport": true,
        "detail": "kmodes.kmodes",
        "documentation": {}
    },
    {
        "label": "silhouette_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "calinski_harabasz_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "davies_bouldin_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "confusion_matrix",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "confusion_matrix",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "classification_report",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "roc_curve",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "roc_auc_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "roc_curve",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "auc",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "adjusted_rand_score",
        "importPath": "sklearn.metrics.cluster",
        "description": "sklearn.metrics.cluster",
        "isExtraImport": true,
        "detail": "sklearn.metrics.cluster",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "src.obesity",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "src.obesity",
        "description": "src.obesity",
        "detail": "src.obesity",
        "documentation": {}
    },
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "page_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "sidebar_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "page_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "sidebar_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "page_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "sidebar_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "page_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "COEF_SIL_HELP",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "DB_HELP",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "CH_HELP",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "N_INIT_HELP",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "RDM_STE_HELP",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "page_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "sidebar_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "COLS_CLUSTER_LABEL",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "page_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "sidebar_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "page_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "sidebar_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "LABEL_SIZE",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "TITLE_SIZE",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "LABEL_SIZE",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "TITLE_SIZE",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "page_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "sidebar_config",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "BMI_HELP",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "CC_HELP",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "RCC_HELP",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "ICT_HELP",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "OBESITY_HELP",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "COMMENTS_HELP",
        "importPath": "src.app_config",
        "description": "src.app_config",
        "isExtraImport": true,
        "detail": "src.app_config",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "obesity_data_etl",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_return_data",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_clusters_kmodes",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_return_data",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_return_data",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_return_nb_clusters",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_update_var",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_data_etl",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_return_data",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_data_etl",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_return_data",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_prediction",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "save_obesity_info",
        "importPath": "src.call_api",
        "description": "src.call_api",
        "isExtraImport": true,
        "detail": "src.call_api",
        "documentation": {}
    },
    {
        "label": "src.eda_functions",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "src.eda_functions",
        "description": "src.eda_functions",
        "detail": "src.eda_functions",
        "documentation": {}
    },
    {
        "label": "src.chart_common_functions",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "src.chart_common_functions",
        "description": "src.chart_common_functions",
        "detail": "src.chart_common_functions",
        "documentation": {}
    },
    {
        "label": "src.clustering_functions",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "src.clustering_functions",
        "description": "src.clustering_functions",
        "detail": "src.clustering_functions",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "matplotlib.ticker",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.ticker",
        "description": "matplotlib.ticker",
        "detail": "matplotlib.ticker",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "altair",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "altair",
        "description": "altair",
        "detail": "altair",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "skew",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "kurtosis",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "shapiro",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "iqr",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "kurtosis",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "skew",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "norm",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "uniform",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "BorutaShap",
        "importPath": "BorutaShap",
        "description": "BorutaShap",
        "isExtraImport": true,
        "detail": "BorutaShap",
        "documentation": {}
    },
    {
        "label": "statsmodels.api",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statsmodels.api",
        "description": "statsmodels.api",
        "detail": "statsmodels.api",
        "documentation": {}
    },
    {
        "label": "cross_val_predict",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "RandomizedSearchCV",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "StratifiedKFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "cross_val_score",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "KFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "OneVsRestClassifier",
        "importPath": "sklearn.multiclass",
        "description": "sklearn.multiclass",
        "isExtraImport": true,
        "detail": "sklearn.multiclass",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "stats",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "python_clustering",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "python_clustering",
        "description": "python_clustering",
        "detail": "python_clustering",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "ECOD",
        "importPath": "pyod.models.ecod",
        "description": "pyod.models.ecod",
        "isExtraImport": true,
        "detail": "pyod.models.ecod",
        "documentation": {}
    },
    {
        "label": "GradientBoostingClassifier",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "StackingClassifier",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "XGBClassifier",
        "importPath": "xgboost",
        "description": "xgboost",
        "isExtraImport": true,
        "detail": "xgboost",
        "documentation": {}
    },
    {
        "label": "LGBMClassifier",
        "importPath": "lightgbm",
        "description": "lightgbm",
        "isExtraImport": true,
        "detail": "lightgbm",
        "documentation": {}
    },
    {
        "label": "CatBoostClassifier",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "open_connection",
        "kind": 2,
        "importPath": "src.api.src.bd",
        "description": "src.api.src.bd",
        "peekOfCode": "def open_connection():\n    conn = sqlite3.connect(URL_DB)\n    return conn\ndef close_connection(conn):\n    conn.commit()\n    conn.close()\ndef exec_query_result(query, conn, varios=True):\n    cur = conn.cursor()\n    cur.execute(query)\n    if varios:",
        "detail": "src.api.src.bd",
        "documentation": {}
    },
    {
        "label": "close_connection",
        "kind": 2,
        "importPath": "src.api.src.bd",
        "description": "src.api.src.bd",
        "peekOfCode": "def close_connection(conn):\n    conn.commit()\n    conn.close()\ndef exec_query_result(query, conn, varios=True):\n    cur = conn.cursor()\n    cur.execute(query)\n    if varios:\n        return cur.fetchall()\n    else: \n        return cur.fetchone()",
        "detail": "src.api.src.bd",
        "documentation": {}
    },
    {
        "label": "exec_query_result",
        "kind": 2,
        "importPath": "src.api.src.bd",
        "description": "src.api.src.bd",
        "peekOfCode": "def exec_query_result(query, conn, varios=True):\n    cur = conn.cursor()\n    cur.execute(query)\n    if varios:\n        return cur.fetchall()\n    else: \n        return cur.fetchone()\ndef exec_query(query, conn):\n    cur = conn.cursor()\n    cur.execute(query)",
        "detail": "src.api.src.bd",
        "documentation": {}
    },
    {
        "label": "exec_query",
        "kind": 2,
        "importPath": "src.api.src.bd",
        "description": "src.api.src.bd",
        "peekOfCode": "def exec_query(query, conn):\n    cur = conn.cursor()\n    cur.execute(query)\n    conn.commit()",
        "detail": "src.api.src.bd",
        "documentation": {}
    },
    {
        "label": "CURRENT_DIR",
        "kind": 5,
        "importPath": "src.api.src.bd",
        "description": "src.api.src.bd",
        "peekOfCode": "CURRENT_DIR = Path.cwd()\nBASE_DIR = Path(CURRENT_DIR).parent\nURL_DB = f\"{CURRENT_DIR / 'data/db/antropometry'}\"\ndef open_connection():\n    conn = sqlite3.connect(URL_DB)\n    return conn\ndef close_connection(conn):\n    conn.commit()\n    conn.close()\ndef exec_query_result(query, conn, varios=True):",
        "detail": "src.api.src.bd",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "src.api.src.bd",
        "description": "src.api.src.bd",
        "peekOfCode": "BASE_DIR = Path(CURRENT_DIR).parent\nURL_DB = f\"{CURRENT_DIR / 'data/db/antropometry'}\"\ndef open_connection():\n    conn = sqlite3.connect(URL_DB)\n    return conn\ndef close_connection(conn):\n    conn.commit()\n    conn.close()\ndef exec_query_result(query, conn, varios=True):\n    cur = conn.cursor()",
        "detail": "src.api.src.bd",
        "documentation": {}
    },
    {
        "label": "URL_DB",
        "kind": 5,
        "importPath": "src.api.src.bd",
        "description": "src.api.src.bd",
        "peekOfCode": "URL_DB = f\"{CURRENT_DIR / 'data/db/antropometry'}\"\ndef open_connection():\n    conn = sqlite3.connect(URL_DB)\n    return conn\ndef close_connection(conn):\n    conn.commit()\n    conn.close()\ndef exec_query_result(query, conn, varios=True):\n    cur = conn.cursor()\n    cur.execute(query)",
        "detail": "src.api.src.bd",
        "documentation": {}
    },
    {
        "label": "read_file",
        "kind": 2,
        "importPath": "src.api.src.data_common_functions",
        "description": "src.api.src.data_common_functions",
        "peekOfCode": "def read_file(file, sep=','):\n    df = pd.DataFrame()\n    file_type = file[file.index('.') - len(file) + 1:]\n    print(file_type)\n    if (file_type == 'csv'):\n        df = pd.read_csv(file, sep=sep)\n    elif (file_type == 'parquet'):\n        df = pd.read_parquet(file, engine='fastparquet')\n    elif (file_type == 'xlsx' or file_type == 'xls'):\n        df = pd.read_excel(file)",
        "detail": "src.api.src.data_common_functions",
        "documentation": {}
    },
    {
        "label": "select_data",
        "kind": 2,
        "importPath": "src.api.src.data_common_functions",
        "description": "src.api.src.data_common_functions",
        "peekOfCode": "def select_data(df, col_drop=[], col_leave=[]):\n    if col_leave:\n        df = df.loc[:,col_leave]\n    if col_drop:\n        df.drop(col_drop, axis=1, inplace=True)\n    return df\n# Crea y transforma el DF para utilizar los algoritmos\n# con las variables: age_range, gender, height, weight, waist_circum_preferred y hip_circum\ndef transform_df(df, columns_to_encode, columns_to_scale, columns_to_pass):\n    ordinal_cols = ( ['age_range'] if 'age_range' in columns_to_encode else [] )",
        "detail": "src.api.src.data_common_functions",
        "documentation": {}
    },
    {
        "label": "transform_df",
        "kind": 2,
        "importPath": "src.api.src.data_common_functions",
        "description": "src.api.src.data_common_functions",
        "peekOfCode": "def transform_df(df, columns_to_encode, columns_to_scale, columns_to_pass):\n    ordinal_cols = ( ['age_range'] if 'age_range' in columns_to_encode else [] )\n    columns_to_encode = ( ['gender'] if 'gender' in columns_to_encode else [] )\n    ordinal_encoding = ColumnTransformer([\n        (\n            'ordinal_encoding',\n            OrdinalEncoder(categories=[['17-25', '26-35', '36-45', '46-55', '56-65', '66-100']]),\n            ordinal_cols\n        )\n    ])",
        "detail": "src.api.src.data_common_functions",
        "documentation": {}
    },
    {
        "label": "PersonObesity",
        "kind": 6,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "class PersonObesity(BaseModel):\n    age: int = 18\n    gender: str = Field(..., description=\"Género de la persona\", pattern=\"^(female|male)$\")\n    weight: confloat(gt=0) \n    height: confloat(gt=0)\n    waist_circum_preferred: confloat(gt=0) \n    hip_circum: confloat(gt=0) \nclass PredictedObesityTable(BaseModel):\n    age: float\n    age_range: constr(regex='^(17-25|26-35|36-45|46-55|56-65|66-100)$')",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "PredictedObesityTable",
        "kind": 6,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "class PredictedObesityTable(BaseModel):\n    age: float\n    age_range: constr(regex='^(17-25|26-35|36-45|46-55|56-65|66-100)$')\n    gender:  str = Field(..., description=\"Género de la persona\", pattern=\"^(female|male)$\")\n    height: float\n    weight: float\n    waist_circum_preferred: float\n    hip_circum: float\n    gender_bin: int\n    bmi: float",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "ObesityTable",
        "kind": 6,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "class ObesityTable(BaseModel):\n    age: float\n    age_range: constr(regex='^(17-25|26-35|36-45|46-55|56-65|66-100)$')\n    gender:  str = Field(..., description=\"Género de la persona\", pattern=\"^(female|male)$\")\n    height: float\n    weight: float\n    waist_circum_preferred: float\n    hip_circum: float\n    gender_bin: int\n    bmi: float",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "ParamsKModes",
        "kind": 6,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "class ParamsKModes(BaseModel):\n    n_clusters: conint(gt=1)\n    n_init: conint(gt=0)\n    random_state: conint(gt=0)\nclass ParamsObesity(BaseModel):\n    obesity: Optional[int] = None\n    cluster: Optional[int] = None\n    age_range: Optional[str] = None\n    bmi: Optional[int] = None\n    cc: Optional[int] = None",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "ParamsObesity",
        "kind": 6,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "class ParamsObesity(BaseModel):\n    obesity: Optional[int] = None\n    cluster: Optional[int] = None\n    age_range: Optional[str] = None\n    bmi: Optional[int] = None\n    cc: Optional[int] = None\n    rcc: Optional[int] = None\n    ict: Optional[int] = None\ndef save_data_obesity(df, table, repĺace=True):\n    conn = open_connection()",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "save_data_obesity",
        "kind": 2,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "def save_data_obesity(df, table, repĺace=True):\n    conn = open_connection()\n    action = ('replace' if repĺace else 'append') \n    df.to_sql(table, conn, if_exists=action, index=False)\n    close_connection(conn)\ndef update_data_obesity(query):\n    conn = open_connection()\n    exec_query(query, conn)\n    close_connection(conn)\ndef return_data_obesity():",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "update_data_obesity",
        "kind": 2,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "def update_data_obesity(query):\n    conn = open_connection()\n    exec_query(query, conn)\n    close_connection(conn)\ndef return_data_obesity():\n    conn = open_connection()\n    query = f'SELECT * FROM obesity'\n    result = pd.read_sql_query(query, conn)\n    #result = exec_query_result(query, conn, True)\n    close_connection(conn)",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "return_data_obesity",
        "kind": 2,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "def return_data_obesity():\n    conn = open_connection()\n    query = f'SELECT * FROM obesity'\n    result = pd.read_sql_query(query, conn)\n    #result = exec_query_result(query, conn, True)\n    close_connection(conn)\n    return result\ndef return_number_clusters():\n    conn = open_connection()\n    query = f'SELECT MAX(cluster) + 1 FROM obesity'",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "return_number_clusters",
        "kind": 2,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "def return_number_clusters():\n    conn = open_connection()\n    query = f'SELECT MAX(cluster) + 1 FROM obesity'\n    result = exec_query_result(query, conn, False)\n    close_connection(conn)\n    return result[0]\ndef make_obesity_prediction(person: PersonObesity):\n    person = person.dict()\n    df = pd.DataFrame([person])\n    df_transformed = custom_calculus(df)",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "make_obesity_prediction",
        "kind": 2,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "def make_obesity_prediction(person: PersonObesity):\n    person = person.dict()\n    df = pd.DataFrame([person])\n    df_transformed = custom_calculus(df)\n    cols_to_leave = ['age', 'gender_bin', 'obesity_cc', 'obesity_bmi', 'obesity_rcc', 'obesity_ict']  \n    df_transformed = select_data(df_transformed, [], cols_to_leave)\n    with open(f\"{CURRENT_DIR}/ml_models/rf_obesity.pkl\", \"rb\") as f:\n        trained_model = pickle.load(f)\n    df['obesity'] = trained_model.predict(df_transformed) \n    df['age_range'] = calc_age_range(person['age'])",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "make_obesity_data_etl",
        "kind": 2,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "def make_obesity_data_etl(replace=True):\n    if replace:\n        columns_to_drop = []\n        columns_to_leave = [\n            'age',\n            'age_range',\n            'gender',\n            'height',\n            'weight',\n            'waist_circum_preferred',",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "make_clusters_kmodes",
        "kind": 2,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "def make_clusters_kmodes(params: ParamsKModes):\n    params = params.dict()\n    df_obesity = return_data_obesity()\n    (df_obesity, metrics) = generate_kmodes_clusters(df_obesity, \n                                                     params['n_clusters'], \n                                                     params['n_init'], \n                                                     params['random_state'])\n    df_obesity['cluster_kmodes_date'] = datetime.datetime.now() \n    save_data_obesity(df_obesity, 'Obesity')\n    return metrics",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "update_obesity",
        "kind": 2,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "def update_obesity(params: ParamsObesity):\n    params = params.dict()\n    query = f\"UPDATE obesity SET obesity = {params['obesity']}, obesity_date = '{datetime.datetime.now()}' \"\n    # if params['cluster']:\n    #     query_where = f\"cluster={params['cluster'] }\"\n    # else:\n    query_where = f\"WHERE cluster={params['cluster']} AND \"\n    query_where = query_where + f\"age_range='{params['age_range']}' AND \"\n    query_where = query_where + f\"obesity_bmi={params['bmi']} AND \"\n    query_where = query_where + f\"obesity_cc={params['cc']} AND \"",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "save_obesity_predicted",
        "kind": 2,
        "importPath": "src.api.src.obesity",
        "description": "src.api.src.obesity",
        "peekOfCode": "def save_obesity_predicted(info: PredictedObesityTable):\n    info = info.dict()\n    df = pd.DataFrame(info, index=[0])\n    df['creation_date'] = datetime.datetime.now()\n    save_data_obesity(df, 'PredictedObesity', False)\n    items = df.to_dict(orient = 'records')\n    validated_items = [PredictedObesityTable(**item) for item in items]\n    return validated_items",
        "detail": "src.api.src.obesity",
        "documentation": {}
    },
    {
        "label": "calc_age_range",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def calc_age_range(age):\n    if age >= 17 and age < 26 : return '17-25'\n    if age >= 26 and age < 36 : return '26-35'\n    if age >= 36 and age < 46 : return '36-45'\n    if age >= 46 and age < 56 : return '46-55'\n    if age >= 56 and age < 66 : return '56-65'\n    if age >= 66 : return '66-100'\n# Clasificación según BMI: Body Mass Index (Índice de Masa Corporal)\n# Cálculo del índice de masa corporal (BMI)\ndef bmi_calc(weight, height):",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "bmi_calc",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def bmi_calc(weight, height):\n    height = height/100\n    bmi = weight / (height*height)    \n    return bmi\ndef calc_obesity_bmi(bmi):\n    if bmi < 18.5: return 0\n    if bmi >= 18.5 and bmi < 25 : return 1\n    if bmi >= 25 and bmi < 30 : return 2\n    if bmi >= 30 : return 3\ndef calc_obesity_bmi_txt(bmi):",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "calc_obesity_bmi",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def calc_obesity_bmi(bmi):\n    if bmi < 18.5: return 0\n    if bmi >= 18.5 and bmi < 25 : return 1\n    if bmi >= 25 and bmi < 30 : return 2\n    if bmi >= 30 : return 3\ndef calc_obesity_bmi_txt(bmi):\n    if bmi == 0: return '0-Bajo Peso'\n    if bmi == 1 : return '1-Normal'\n    if bmi == 2 : return '2-Sobrepeso'\n    if bmi == 3 : return '3-Obesidad'",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "calc_obesity_bmi_txt",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def calc_obesity_bmi_txt(bmi):\n    if bmi == 0: return '0-Bajo Peso'\n    if bmi == 1 : return '1-Normal'\n    if bmi == 2 : return '2-Sobrepeso'\n    if bmi == 3 : return '3-Obesidad'\n# Clasificación según CC: Circunferencia de cadera\ndef calc_obesity_cc(gender, waist_circum):\n    if gender=='male':\n        if waist_circum>94.0: return 1            \n    if gender=='female':",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "calc_obesity_cc",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def calc_obesity_cc(gender, waist_circum):\n    if gender=='male':\n        if waist_circum>94.0: return 1            \n    if gender=='female':\n        if waist_circum>80.0: return 1 \n    return 0\ndef calc_obesity_cc_txt(cc):\n    if cc == 0: return '0-Bajo'\n    if cc == 1 : return '1-Alto'\n# Clasificación según RCC: Racio entre la circunferencia de la cintura y el de la cadera",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "calc_obesity_cc_txt",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def calc_obesity_cc_txt(cc):\n    if cc == 0: return '0-Bajo'\n    if cc == 1 : return '1-Alto'\n# Clasificación según RCC: Racio entre la circunferencia de la cintura y el de la cadera\ndef calc_obesity_rcc(gender, rcc):\n    if gender == 'female':\n        if rcc <= 0.8: return 0\n        if rcc > 0.8 and rcc <= 0.85 : return 1\n        if rcc > 0.85 : return 2\n    if gender == 'male':",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "calc_obesity_rcc",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def calc_obesity_rcc(gender, rcc):\n    if gender == 'female':\n        if rcc <= 0.8: return 0\n        if rcc > 0.8 and rcc <= 0.85 : return 1\n        if rcc > 0.85 : return 2\n    if gender == 'male':\n        if rcc <= 0.95: return 0\n        if rcc > 0.95 and rcc <= 1 : return 1\n        if rcc > 1 : return 2\ndef calc_obesity_rcc_txt(rcc):",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "calc_obesity_rcc_txt",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def calc_obesity_rcc_txt(rcc):\n    if rcc == 0: return '0-Bajo'\n    if rcc == 1: return '1-Medio'\n    if rcc == 2: return '2-Alto'\n# Clasificación ICT: Índice o racio de circunferencia de cintura y talla (estatura)\ndef calc_obesity_ict(gender, ict):\n    if gender == 'female':\n        if ict <= 0.41: return 0\n        if ict > 0.41 and ict <= 0.48 : return 1\n        if ict > 0.48 and ict <= 0.57 : return 2",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "calc_obesity_ict",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def calc_obesity_ict(gender, ict):\n    if gender == 'female':\n        if ict <= 0.41: return 0\n        if ict > 0.41 and ict <= 0.48 : return 1\n        if ict > 0.48 and ict <= 0.57 : return 2\n        if ict > 0.57 : return 3\n    if gender == 'male':\n        if ict <= 0.42: return 0\n        if ict > 0.42 and ict <= 0.52 : return 1\n        if ict > 0.52 and ict <= 0.62 : return 2",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "calc_obesity_ict_txt",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def calc_obesity_ict_txt(ict):\n    if ict == 0 : return '0-Delgado'\n    if ict == 1 : return '1-Normal'\n    if ict == 2 : return '2-Sobrepeso'\n    if ict == 3 : return '3-Obesidad'\n# Cuántos factores de riesgo posee una persona\ndef calc_risk_factors(bmi, cc, rcc, ict):  \n    total = 0\n    if bmi >= 2: total = total + 1\n    if cc >= 1: total = total + 1",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "calc_risk_factors",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def calc_risk_factors(bmi, cc, rcc, ict):  \n    total = 0\n    if bmi >= 2: total = total + 1\n    if cc >= 1: total = total + 1\n    if rcc >= 1: total = total + 1\n    if ict >= 2: total = total + 1\n    return total\n# Transforma los datos del dataset, \n# en particular pasa las medidas de pulgadas a cm\n# y de libras a Kg",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "custom_transformations",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def custom_transformations(df):\n    # Columnas que no están en cm\n    not_in_cm = ['age', 'age_range', 'gender', 'weight', 'num_children', 'bra_size_chest', 'bra_size_cup', 'shoe_size_us']\n    # Columnas en cm: Son todas las columnas menos las que se encuentran más arriba\n    in_cm_columns = [ele for ele in df.select_dtypes('float64').columns.to_list() if ele not in not_in_cm]\n    # Transformamos de pulgadas a cm \n    for col in in_cm_columns:\n        df[col] = df.apply(lambda  row: row[col] * 2.54, axis=1)\n    # Transformamos de libras a Kg\n    df['weight'] = df.apply(lambda  row: row['weight'] * 0.454, axis=1)",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "custom_calculus",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def custom_calculus(df):\n    df['gender_bin'] = df.apply(lambda  row: (1 if row['gender']=='male' else 0), axis=1)\n    # Calculamos el BMI para cada registro\n    df['bmi'] = df.apply(lambda  row: bmi_calc(row['weight'], row['height']) , axis=1)\n    # Calculamos el racio cintura / cadera para cada registro\n    df['rcc'] = df.apply(lambda  row: row['waist_circum_preferred'] / row['hip_circum'], axis=1)\n    # Calculamos el racio cintura / talla para cada registro\n    df['ict'] = df.apply(lambda  row: row['waist_circum_preferred'] / row['height'], axis=1)\n    df['obesity_bmi'] = df.apply(lambda  row: calc_obesity_bmi(row['bmi']) , axis=1)\n    df['obesity_bmi_txt'] = df.apply(lambda  row: calc_obesity_bmi_txt(row['obesity_bmi']) , axis=1)",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "transform_calcul",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def transform_calcul(df):\n    # Aplicamos transformaciones y cálculos personalizados\n    custom_transformations_pipeline = Pipeline([\n        ('custom_transforms', FunctionTransformer(custom_transformations)), # Función de transformación personalizada\n        ('custom_calculus', FunctionTransformer(custom_calculus)) # Función de cálculos personalizados\n    ])\n    # Aplicar el pipeline al conjunto de datos\n    return custom_transformations_pipeline.fit_transform(df)\n# Esta función puede ser utilizada para extraer un subconjunto de datos del dataset original\n# Parámetros:",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "load_clean_transform",
        "kind": 2,
        "importPath": "src.api.src.obesity_etl_functions",
        "description": "src.api.src.obesity_etl_functions",
        "peekOfCode": "def load_clean_transform(columns_to_drop, columns_to_leave, transform=True):\n    import pickle\n    ## Workflow: Extracción\n    ########################################\n    file = f\"{CURRENT_DIR}/data/in/caesar.csv\"\n    df = read_file(file, ',')\n    # Limpio y eliminos los datos erróneos\n    # Borro la primera línea que no contiene datos significativos\n    df.drop([0], axis=0, inplace=True)\n    # Selecciono las variables que me interesan",
        "detail": "src.api.src.obesity_etl_functions",
        "documentation": {}
    },
    {
        "label": "generate_kmodes_clusters",
        "kind": 2,
        "importPath": "src.api.src.obesity_kmodes_functions",
        "description": "src.api.src.obesity_kmodes_functions",
        "peekOfCode": "def generate_kmodes_clusters(df, n_clusters, n_init, random_state, eda_report=True):    \n    df_kmodes = _generate_df_kmodes(df)\n    k_modes = KModes(n_clusters=n_clusters, init='Huang', n_init=n_init, random_state=random_state)\n    cluster_labels = k_modes.fit_predict(df_kmodes)\n    # Agrega los resultados de la agrupación al dataframe original\n    df['cluster'] = cluster_labels\n    # Métricas del modelo\n    metrics = {\n        'model': 'KModes',\n        'n_clusters': n_clusters,",
        "detail": "src.api.src.obesity_kmodes_functions",
        "documentation": {}
    },
    {
        "label": "read_root",
        "kind": 2,
        "importPath": "src.api.api",
        "description": "src.api.api",
        "peekOfCode": "def read_root():\n    print('hola')\n    return {'message': 'API Medidas Antropométricas'}\n# Return obesity prediction for a person\n@app.post('/obesity_prediction')\nasync def obesity_prediction(person: ob.PersonObesity):\n    result = ob.make_obesity_prediction(person)\n    return result\n# Save obesity prediction and real information\n@app.patch('/obesity_prediction')",
        "detail": "src.api.api",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "src.api.api",
        "description": "src.api.api",
        "peekOfCode": "app = FastAPI() \n@app.get(\"/\")\ndef read_root():\n    print('hola')\n    return {'message': 'API Medidas Antropométricas'}\n# Return obesity prediction for a person\n@app.post('/obesity_prediction')\nasync def obesity_prediction(person: ob.PersonObesity):\n    result = ob.make_obesity_prediction(person)\n    return result",
        "detail": "src.api.api",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "def main():\n    # Configuración de la página\n    st.set_page_config(layout=\"wide\", page_icon='💪', page_title='Obeso o No')\n    st.title(titulo)\n    st.write(subtitulo)\n    # Formulario para ingresar los datos\n    formulario = st.form(\"Datos de entrada\")\n    genero = formulario.selectbox('Género', ['Masculino', 'Femenino'])\n    edad = formulario.number_input('¿Qué edad tienes?', min_value=1, max_value=100)\n    antecedentes_familiares = formulario.selectbox('¿Tienes antecedentes familiares de sobrepeso?', ['Sí', 'No'])",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "titulo",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "titulo = '¿Obeso o no? 💪'\nsubtitulo = 'Predice el nivel de obesidad con aprendizaje automático'\ndef main():\n    # Configuración de la página\n    st.set_page_config(layout=\"wide\", page_icon='💪', page_title='Obeso o No')\n    st.title(titulo)\n    st.write(subtitulo)\n    # Formulario para ingresar los datos\n    formulario = st.form(\"Datos de entrada\")\n    genero = formulario.selectbox('Género', ['Masculino', 'Femenino'])",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "subtitulo",
        "kind": 5,
        "importPath": "src.app.app",
        "description": "src.app.app",
        "peekOfCode": "subtitulo = 'Predice el nivel de obesidad con aprendizaje automático'\ndef main():\n    # Configuración de la página\n    st.set_page_config(layout=\"wide\", page_icon='💪', page_title='Obeso o No')\n    st.title(titulo)\n    st.write(subtitulo)\n    # Formulario para ingresar los datos\n    formulario = st.form(\"Datos de entrada\")\n    genero = formulario.selectbox('Género', ['Masculino', 'Femenino'])\n    edad = formulario.number_input('¿Qué edad tienes?', min_value=1, max_value=100)",
        "detail": "src.app.app",
        "documentation": {}
    },
    {
        "label": "st.latex('IMC",
        "kind": 5,
        "importPath": "src.streamlit.pages.1 - Descripción del Estudio",
        "description": "src.streamlit.pages.1 - Descripción del Estudio",
        "peekOfCode": "st.latex('IMC = Peso (Kg) / Altura (m)^2')\nst.latex('RCC = Cintura (cm) / Cadera (cm)')\nst.latex('RCT = Cintura (cm) / Altura (cm)')\nst.markdown(\n    '''\n    Luego, existen tablas que permiten clasificar el grado de sobrepeso y obesidad y el riesgo de tener exceso de grasa abdominal, en función de los valores obtenidos:\n    1. Clasificación de obesidad según el IMC:\n    |Riesgo|IMC|\n    |------|---------|\n    |Peso bajo | < 18.5 |",
        "detail": "src.streamlit.pages.1 - Descripción del Estudio",
        "documentation": {}
    },
    {
        "label": "st.latex('RCC",
        "kind": 5,
        "importPath": "src.streamlit.pages.1 - Descripción del Estudio",
        "description": "src.streamlit.pages.1 - Descripción del Estudio",
        "peekOfCode": "st.latex('RCC = Cintura (cm) / Cadera (cm)')\nst.latex('RCT = Cintura (cm) / Altura (cm)')\nst.markdown(\n    '''\n    Luego, existen tablas que permiten clasificar el grado de sobrepeso y obesidad y el riesgo de tener exceso de grasa abdominal, en función de los valores obtenidos:\n    1. Clasificación de obesidad según el IMC:\n    |Riesgo|IMC|\n    |------|---------|\n    |Peso bajo | < 18.5 |\n    |Peso normal|18.5 - 25 |",
        "detail": "src.streamlit.pages.1 - Descripción del Estudio",
        "documentation": {}
    },
    {
        "label": "st.latex('RCT",
        "kind": 5,
        "importPath": "src.streamlit.pages.1 - Descripción del Estudio",
        "description": "src.streamlit.pages.1 - Descripción del Estudio",
        "peekOfCode": "st.latex('RCT = Cintura (cm) / Altura (cm)')\nst.markdown(\n    '''\n    Luego, existen tablas que permiten clasificar el grado de sobrepeso y obesidad y el riesgo de tener exceso de grasa abdominal, en función de los valores obtenidos:\n    1. Clasificación de obesidad según el IMC:\n    |Riesgo|IMC|\n    |------|---------|\n    |Peso bajo | < 18.5 |\n    |Peso normal|18.5 - 25 |\n    |Sobrepeso|25 - 30 |",
        "detail": "src.streamlit.pages.1 - Descripción del Estudio",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "src.streamlit.pages.3 - EDA",
        "description": "src.streamlit.pages.3 - EDA",
        "peekOfCode": "result = obesity_return_data()\nif result:\n    df_obesity = pd.read_json(result, orient='records')\n    df_eda_f = ef.divide_by_gender(df_obesity, 'female')\n    df_eda_m = ef.divide_by_gender(df_obesity, 'male')\n    st.markdown('#### Resumen estadístico de los datos:')\n    st.markdown('**Datos numéricos**')\n    st.write(df_obesity.describe())\n    st.markdown('**Datos no numéricos**')\n    st.write(df_obesity.select_dtypes(include=['object']).describe())",
        "detail": "src.streamlit.pages.3 - EDA",
        "documentation": {}
    },
    {
        "label": "update_obesity",
        "kind": 2,
        "importPath": "src.streamlit.pages.5 - Análisis y Etiquetado",
        "description": "src.streamlit.pages.5 - Análisis y Etiquetado",
        "peekOfCode": "def update_obesity(df, cluster):\n    for index, row in df.iterrows():\n        params = {\n                    'obesity': row['obesity'],\n                    'cluster': cluster,\n                    'age_range': row['age_range'],\n                    'bmi': int(row['bmi'][:1]),\n                    'cc': int(row['cc'][:1]),\n                    'rcc': int(row['rcc'][:1]),\n                    'ict': int(row['ict'][:1])",
        "detail": "src.streamlit.pages.5 - Análisis y Etiquetado",
        "documentation": {}
    },
    {
        "label": "nb_clusters",
        "kind": 5,
        "importPath": "src.streamlit.pages.5 - Análisis y Etiquetado",
        "description": "src.streamlit.pages.5 - Análisis y Etiquetado",
        "peekOfCode": "nb_clusters = obesity_return_nb_clusters()\nif nb_clusters:\n    result = obesity_return_data()\n    df_obesity = pd.read_json(result, orient='records')\n    clusters = range(int(nb_clusters))\n    cluster = st.selectbox('**Selecciona el cluster o grupo que quieres analizar:**', (clusters))\n    df_cluster = cf.eda_cluster(df_obesity, cluster)\n    with st.form('form_analisis'):\n        cols_disabled = [\"age_range\", \"bmi\", \"cc\", \"rcc\", \"ict\",\n                        \"risk_factors\", \"total\", \"label\"]",
        "detail": "src.streamlit.pages.5 - Análisis y Etiquetado",
        "documentation": {}
    },
    {
        "label": "page_config",
        "kind": 2,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "def page_config():\n    return st.set_page_config(\n        page_title='dIAna Antropometría y Obesidad', \n        page_icon=':health_worker:', \n        layout=\"centered\", \n        initial_sidebar_state=\"auto\", \n        menu_items={\n            'Get Help': None,\n            'Report a bug': None,\n            'About': '''## Medidas Antropométricas para el predecir el riesgo de obesidad y ENT ",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "sidebar_config",
        "kind": 2,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "def sidebar_config():\n    st.sidebar.markdown(':orange[El estudio de los datos, la clasificación y el entrenamiento del modelo, no afectan el modelo ya existente y utilizado para las predicciones.]')\nLABEL_SIZE=12\nTITLE_SIZE=16\nBMI_HELP = '''\n      Índice de Masa Corporal.\\n\n      \\t0 - Peso Bajo\\n\n      \\t1 - Peso Normal\\n\n      \\t2 - Sobrepeso\\n\n      \\t3 - Obesidad",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "BMI_HELP",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "BMI_HELP = '''\n      Índice de Masa Corporal.\\n\n      \\t0 - Peso Bajo\\n\n      \\t1 - Peso Normal\\n\n      \\t2 - Sobrepeso\\n\n      \\t3 - Obesidad\n'''\nCC_HELP = '''\n      Contorno de Cintura (CC) y acumulación de grasa abdominal.\\n\n      \\t0 - Sin riesgo\\n",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "CC_HELP",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "CC_HELP = '''\n      Contorno de Cintura (CC) y acumulación de grasa abdominal.\\n\n      \\t0 - Sin riesgo\\n\n      \\t1 - Riesgo o exceso de grasa abdominal\n'''\nRCC_HELP = '''\n      Relación entre el Contorno de Cintura y la Cadera.\\n\n      \\t0 - Sin riesgo\\n\n      \\t1 - Riesgo medio\\n\n      \\t2 - Riesgo alto",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "RCC_HELP",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "RCC_HELP = '''\n      Relación entre el Contorno de Cintura y la Cadera.\\n\n      \\t0 - Sin riesgo\\n\n      \\t1 - Riesgo medio\\n\n      \\t2 - Riesgo alto\n'''\nICT_HELP = '''\n      Relación entre el Contorno de Cintura y la Estatura.\\n\n      \\t0 - Delgado\\n\n      \\t1 - Peso Normal\\n",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "ICT_HELP",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "ICT_HELP = '''\n      Relación entre el Contorno de Cintura y la Estatura.\\n\n      \\t0 - Delgado\\n\n      \\t1 - Peso Normal\\n\n      \\t2 - Sobrepeso\\n\n      \\t3 - Obesidad\n'''\nOBESITY_HELP = '''\n    Asigna un valor entre 0 y 2:\\n\n    \\t0 - Riesgo bajo o nulo: La persona no padece ninguna ENT y a priori ",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "OBESITY_HELP",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "OBESITY_HELP = '''\n    Asigna un valor entre 0 y 2:\\n\n    \\t0 - Riesgo bajo o nulo: La persona no padece ninguna ENT y a priori \n          tiene un riesgo nulo o bajo de padecerlas.\\n\n    \\t1 - Riesgo medio: La persona no padece ninguna ENT pero hay indicadores \n          que señalan que podría comenzar a padecerlas: Puede estar desarrollando \n          resistencia a la insulina o tener episodios de hipertensión, por ejemplo.\\n\n    \\t2 - Riesgo alto: La persona padece alguna ENT, diagnosticada o no.\n'''\nCOMMENTS_HELP = '''",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "COMMENTS_HELP",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "COMMENTS_HELP = '''\n    Cualquier información relevante sobre el estado del paciente:\\n\n    Si padece de patologías como hipertensión, diabetes, enfermedades cardiovasculares, etc.\\n\n    Información relevante que podría estar relacionada con el peso y la acumulación de grasa.\n'''\nN_INIT_HELP = '''\n    **n_init** es el número de veces que se ejecutará el algoritmo con diferentes semillas aleatorias. El valor predeterminado es 10. Un valor mayor de n_init puede ayudar a encontrar una solución más óptima, pero también puede aumentar el tiempo de ejecución.\n'''\nRDM_STE_HELP = '''\n    **random_state** es una semilla aleatoria que se utiliza para inicializar el generador de números aleatorios. Un valor constante de random_state garantizará que el algoritmo produzca los mismos resultados cada vez que se ejecute.",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "N_INIT_HELP",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "N_INIT_HELP = '''\n    **n_init** es el número de veces que se ejecutará el algoritmo con diferentes semillas aleatorias. El valor predeterminado es 10. Un valor mayor de n_init puede ayudar a encontrar una solución más óptima, pero también puede aumentar el tiempo de ejecución.\n'''\nRDM_STE_HELP = '''\n    **random_state** es una semilla aleatoria que se utiliza para inicializar el generador de números aleatorios. Un valor constante de random_state garantizará que el algoritmo produzca los mismos resultados cada vez que se ejecute.\n'''\nCOLS_CLUSTER_LABEL = {\n  \"age_range\": 'Rango de Edad',\n  \"bmi\": 'IMC',\n  \"cc\": 'Cintura',",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "RDM_STE_HELP",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "RDM_STE_HELP = '''\n    **random_state** es una semilla aleatoria que se utiliza para inicializar el generador de números aleatorios. Un valor constante de random_state garantizará que el algoritmo produzca los mismos resultados cada vez que se ejecute.\n'''\nCOLS_CLUSTER_LABEL = {\n  \"age_range\": 'Rango de Edad',\n  \"bmi\": 'IMC',\n  \"cc\": 'Cintura',\n  \"rcc\": 'RCC',\n  \"ict\": 'ICT',\n  \"risk_factors\": 'N° factores de riesgo',",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "COLS_CLUSTER_LABEL",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "COLS_CLUSTER_LABEL = {\n  \"age_range\": 'Rango de Edad',\n  \"bmi\": 'IMC',\n  \"cc\": 'Cintura',\n  \"rcc\": 'RCC',\n  \"ict\": 'ICT',\n  \"risk_factors\": 'N° factores de riesgo',\n#   \"obesity\": st.column_config.NumberColumn(\n#             \"Grado de Obesidad\",\n#             help=OBESITY_HELP,",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "COEF_SIL_HELP",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "COEF_SIL_HELP = '''\n      Coeficiente de Silhouette: Varía entre -1 y 1.\\n\n      \\t-1 - Mal agrupamiento\\n\n      \\t0 - Indiferente\\n\n      \\t1 - Buen agrupamiento\n'''\nDB_HELP = '''\n    Valores pequeños para el índice David-Bouldin \n    indican grupos compactos y cuyos centros \n    están bien separados los unos de los otros.",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "DB_HELP",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "DB_HELP = '''\n    Valores pequeños para el índice David-Bouldin \n    indican grupos compactos y cuyos centros \n    están bien separados los unos de los otros.\n    El número de grupos o clusters que minimiza el índice DB\n    se toma como el óptimo.\n'''\nCH_HELP = '''\n    El índice de Calinski-Harabasz,\n    es una métrica con la que se puede evaluar ",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "CH_HELP",
        "kind": 5,
        "importPath": "src.streamlit.src.app_config",
        "description": "src.streamlit.src.app_config",
        "peekOfCode": "CH_HELP = '''\n    El índice de Calinski-Harabasz,\n    es una métrica con la que se puede evaluar \n    el grado de agrupación de un conjunto de datos. \n    Cuando mayor sea el valor del índice, \n    mejor será la agrupación.\n'''",
        "detail": "src.streamlit.src.app_config",
        "documentation": {}
    },
    {
        "label": "obesity_prediction",
        "kind": 2,
        "importPath": "src.streamlit.src.call_api",
        "description": "src.streamlit.src.call_api",
        "peekOfCode": "def obesity_prediction(person):\n      url = URL_BASE + '/obesity_prediction'                  \n      person = json.dumps(person) \n      try:\n            response = requests.post(url,\n                              headers={'Content-Type': 'application/json'},\n                              data=person,\n                              timeout=8000)\n            return json.loads(response.content)\n      except requests.exceptions.RequestException as e:",
        "detail": "src.streamlit.src.call_api",
        "documentation": {}
    },
    {
        "label": "save_obesity_info",
        "kind": 2,
        "importPath": "src.streamlit.src.call_api",
        "description": "src.streamlit.src.call_api",
        "peekOfCode": "def save_obesity_info(info):\n      url = URL_BASE + '/obesity_prediction'                  \n      info = json.dumps(info) \n      try:\n            response = requests.patch(url,\n                              headers={'Content-Type': 'application/json'},\n                              data=info,\n                              timeout=8000)\n            return json.loads(response.content)\n      except requests.exceptions.RequestException as e:",
        "detail": "src.streamlit.src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_data_etl",
        "kind": 2,
        "importPath": "src.streamlit.src.call_api",
        "description": "src.streamlit.src.call_api",
        "peekOfCode": "def obesity_data_etl(replace):\n      url = URL_BASE + f'/obesity_data_etl/{replace}'\n      try:\n            response = requests.post(url,\n                              headers={'Content-Type': 'application/json'},\n                              timeout=8000)\n            result = io.BytesIO(response.content)\n            return result\n      except requests.exceptions.RequestException as e:\n            # Manejar errores de solicitud (por ejemplo, problemas de red)",
        "detail": "src.streamlit.src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_return_data",
        "kind": 2,
        "importPath": "src.streamlit.src.call_api",
        "description": "src.streamlit.src.call_api",
        "peekOfCode": "def obesity_return_data():\n      url = URL_BASE + f'/obesity_data'\n      try:\n            response = requests.get(url,\n                              headers={'Content-Type': 'application/json'},\n                              timeout=8000)\n            result = io.BytesIO(response.content)\n            return result\n      except requests.exceptions.RequestException as e:\n            # Manejar errores de solicitud (por ejemplo, problemas de red)",
        "detail": "src.streamlit.src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_clusters_kmodes",
        "kind": 2,
        "importPath": "src.streamlit.src.call_api",
        "description": "src.streamlit.src.call_api",
        "peekOfCode": "def obesity_clusters_kmodes(params):\n      url = URL_BASE + '/clusters_kmodes'                  \n      params = json.dumps(params) \n      try:\n            response = requests.post(url,\n                              headers={'Content-Type': 'application/json'},\n                              data=params,\n                              timeout=8000)\n            return json.loads(response.content)\n      except requests.exceptions.RequestException as e:",
        "detail": "src.streamlit.src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_update_var",
        "kind": 2,
        "importPath": "src.streamlit.src.call_api",
        "description": "src.streamlit.src.call_api",
        "peekOfCode": "def obesity_update_var(params):\n      url = URL_BASE + f'/obesity_data'                \n      params = json.dumps(params) \n      try:\n            response = requests.patch(url,\n                              headers={'Content-Type': 'application/json'},\n                              data=params,\n                              timeout=8000)\n            return json.loads(response.content)\n      except requests.exceptions.RequestException as e:",
        "detail": "src.streamlit.src.call_api",
        "documentation": {}
    },
    {
        "label": "obesity_return_nb_clusters",
        "kind": 2,
        "importPath": "src.streamlit.src.call_api",
        "description": "src.streamlit.src.call_api",
        "peekOfCode": "def obesity_return_nb_clusters():\n      url = URL_BASE + f'/nb_clusters'\n      try:\n            response = requests.get(url,\n                              headers={'Content-Type': 'application/json'},\n                              timeout=8000)\n            return json.loads(response.content) #response.content\n      except requests.exceptions.RequestException as e:\n            # Manejar errores de solicitud (por ejemplo, problemas de red)\n            st.error(\"Error de solicitud a la API: \" + str(e))",
        "detail": "src.streamlit.src.call_api",
        "documentation": {}
    },
    {
        "label": "URL_BASE",
        "kind": 5,
        "importPath": "src.streamlit.src.call_api",
        "description": "src.streamlit.src.call_api",
        "peekOfCode": "URL_BASE = 'https://antropo-api-ft3evlkfyq-rj.a.run.app'\n#URL_BASE = 'http://127.0.0.1:8000'\n#URL_BASE = 'http://localhost'\ndef obesity_prediction(person):\n      url = URL_BASE + '/obesity_prediction'                  \n      person = json.dumps(person) \n      try:\n            response = requests.post(url,\n                              headers={'Content-Type': 'application/json'},\n                              data=person,",
        "detail": "src.streamlit.src.call_api",
        "documentation": {}
    },
    {
        "label": "#URL_BASE",
        "kind": 5,
        "importPath": "src.streamlit.src.call_api",
        "description": "src.streamlit.src.call_api",
        "peekOfCode": "#URL_BASE = 'http://127.0.0.1:8000'\n#URL_BASE = 'http://localhost'\ndef obesity_prediction(person):\n      url = URL_BASE + '/obesity_prediction'                  \n      person = json.dumps(person) \n      try:\n            response = requests.post(url,\n                              headers={'Content-Type': 'application/json'},\n                              data=person,\n                              timeout=8000)",
        "detail": "src.streamlit.src.call_api",
        "documentation": {}
    },
    {
        "label": "#URL_BASE",
        "kind": 5,
        "importPath": "src.streamlit.src.call_api",
        "description": "src.streamlit.src.call_api",
        "peekOfCode": "#URL_BASE = 'http://localhost'\ndef obesity_prediction(person):\n      url = URL_BASE + '/obesity_prediction'                  \n      person = json.dumps(person) \n      try:\n            response = requests.post(url,\n                              headers={'Content-Type': 'application/json'},\n                              data=person,\n                              timeout=8000)\n            return json.loads(response.content)",
        "detail": "src.streamlit.src.call_api",
        "documentation": {}
    },
    {
        "label": "num_var_distribution",
        "kind": 2,
        "importPath": "src.streamlit.src.chart_common_functions",
        "description": "src.streamlit.src.chart_common_functions",
        "peekOfCode": "def num_var_distribution(df):\n    fig, axes = plt.subplots(nrows=5, ncols=3, figsize=(12, 10))\n    axes = axes.flat\n    col_num = df.select_dtypes(include=['float64', 'int64']).columns\n    colormap = sns.color_palette('Oranges')\n    for i, colum in enumerate(col_num):\n        sns.histplot(\n            data     = df,\n            x        = colum,\n            stat     = \"count\",",
        "detail": "src.streamlit.src.chart_common_functions",
        "documentation": {}
    },
    {
        "label": "num_var_correl",
        "kind": 2,
        "importPath": "src.streamlit.src.chart_common_functions",
        "description": "src.streamlit.src.chart_common_functions",
        "peekOfCode": "def num_var_correl(df, col):\n    fig, axes = plt.subplots(nrows=3, ncols=3, figsize=(12, 10))\n    axes = axes.flat\n    cols = df.select_dtypes(include=['float64']).columns\n    if col in cols: #df[col].dtype == np.float64 or df[col].dtype == np.int: \n        cols = cols.drop(col)\n    col_num = [col for col in cols if not re.search('date$', col)]\n    for i, colum in enumerate(col_num):\n        sns.regplot(\n            x           = df[col],",
        "detail": "src.streamlit.src.chart_common_functions",
        "documentation": {}
    },
    {
        "label": "distribution_var_categ",
        "kind": 2,
        "importPath": "src.streamlit.src.chart_common_functions",
        "description": "src.streamlit.src.chart_common_functions",
        "peekOfCode": "def distribution_var_categ(df, col, invert=False):\n    fig, axes = plt.subplots(nrows=3, ncols=3, figsize=(18, 15))\n    axes = axes.flat\n    if invert:\n        cols = df.select_dtypes(include=['float64']).columns\n    else:\n        cols = df.select_dtypes(include=['object']).columns\n    object_cols = [col for col in cols if not re.search('date$', col)]\n    for i, colum in enumerate(object_cols):\n        if invert:",
        "detail": "src.streamlit.src.chart_common_functions",
        "documentation": {}
    },
    {
        "label": "bars_chart",
        "kind": 2,
        "importPath": "src.streamlit.src.chart_common_functions",
        "description": "src.streamlit.src.chart_common_functions",
        "peekOfCode": "def bars_chart(df, x_in, y_in, detail, title, title_x, title_y):\n    x = alt.X(x_in, title = title_x, stack='zero', \n          axis = alt.Axis(format = \",.2s\", grid=True, titleAnchor='middle', labelFontSize=LABEL_SIZE))\n    y = alt.Y(y_in, title=title_y, axis = alt.Axis(labelAngle=0, labelFontSize=LABEL_SIZE))\n    tooltip=[alt.Tooltip(detail, title='Grado de obesidad'),\n             alt.Tooltip(y_in, title='Rango de edad'),\n             alt.Tooltip(x_in, title='Cantidad individuos')]\n    bars = alt.Chart(df).mark_bar().encode(\n        x=x,\n        y=y,",
        "detail": "src.streamlit.src.chart_common_functions",
        "documentation": {}
    },
    {
        "label": "pie_chart",
        "kind": 2,
        "importPath": "src.streamlit.src.chart_common_functions",
        "description": "src.streamlit.src.chart_common_functions",
        "peekOfCode": "def pie_chart(df, theta_in, category, title, cat_title):\n    theta = alt.Theta(theta_in, stack=True, title='Total de personas')\n    text = alt.Text(theta_in) \n    base = alt.Chart(df).encode(\n        theta=theta, \n        color=alt.Color(category, scale=alt.Scale(scheme='Oranges'), title=cat_title)\n    ).properties(title={\n                \"text\": title,\n                #\"color\": \"orange\",  # Cambiar color del título\n                \"fontSize\": TITLE_SIZE    # Cambiar tamaño de la fuente del título",
        "detail": "src.streamlit.src.chart_common_functions",
        "documentation": {}
    },
    {
        "label": "clusters_chart",
        "kind": 2,
        "importPath": "src.streamlit.src.clustering_functions",
        "description": "src.streamlit.src.clustering_functions",
        "peekOfCode": "def clusters_chart(df):\n    x = 'count(*):Q'\n    y = 'age_range:O'\n    detail = 'cluster:N'\n    title='Cantidad de Individuos por rango de edad y el Cluster asignado'\n    title_x = 'Total individuos'\n    title_y = 'Rangos de Edad'\n    char = ccf.bars_chart(df, x, y, detail, title, title_x, title_y)\n    return char\ndef define_label(bmi, cc, rcc, ict):",
        "detail": "src.streamlit.src.clustering_functions",
        "documentation": {}
    },
    {
        "label": "define_label",
        "kind": 2,
        "importPath": "src.streamlit.src.clustering_functions",
        "description": "src.streamlit.src.clustering_functions",
        "peekOfCode": "def define_label(bmi, cc, rcc, ict):\n    return bmi + '-' + cc + '-' + rcc + '-' + ict\ndef cluster_labels_chart(df):\n    title = 'Cantidad de individuos por etiqueta'\n    tooltip=[alt.Tooltip('label:N', title='Etiqueta o grupo'),\n             alt.Tooltip('sum(total):Q', title='Cantidad individuos')]\n    bars = alt.Chart(df).mark_bar().encode(\n        x=alt.X('sum(total):Q', title='Total personas'),\n        y=alt.Y('label:N', title='Etiqueta o grupo'),\n        tooltip=tooltip,",
        "detail": "src.streamlit.src.clustering_functions",
        "documentation": {}
    },
    {
        "label": "cluster_labels_chart",
        "kind": 2,
        "importPath": "src.streamlit.src.clustering_functions",
        "description": "src.streamlit.src.clustering_functions",
        "peekOfCode": "def cluster_labels_chart(df):\n    title = 'Cantidad de individuos por etiqueta'\n    tooltip=[alt.Tooltip('label:N', title='Etiqueta o grupo'),\n             alt.Tooltip('sum(total):Q', title='Cantidad individuos')]\n    bars = alt.Chart(df).mark_bar().encode(\n        x=alt.X('sum(total):Q', title='Total personas'),\n        y=alt.Y('label:N', title='Etiqueta o grupo'),\n        tooltip=tooltip,\n        color=alt.Color(\n        'label:N', title='Etiqueta o grupo', legend=alt.Legend(orient=\"bottom\", titleOrient=\"left\")",
        "detail": "src.streamlit.src.clustering_functions",
        "documentation": {}
    },
    {
        "label": "obesity_chart",
        "kind": 2,
        "importPath": "src.streamlit.src.clustering_functions",
        "description": "src.streamlit.src.clustering_functions",
        "peekOfCode": "def obesity_chart(df):\n    chart = alt.Chart(df, width=500, height=alt.Step(10)).mark_bar().encode(\n    y=alt.Y('label:N', axis=None),\n    x=alt.X('sum(total):Q', title='Total personas'),\n    color=alt.Color(\n        'label:N', title='Etiqueta o grupo', legend=alt.Legend(orient=\"bottom\", titleOrient=\"left\")\n    ),\n    tooltip=[alt.Tooltip('label:N', title='Etiqueta'),\n             alt.Tooltip('sum(total):Q', title='Cantidad individuos'),\n             alt.Tooltip('obesity:N', title='Grado de Riesgo')],",
        "detail": "src.streamlit.src.clustering_functions",
        "documentation": {}
    },
    {
        "label": "clusters_factors_charts",
        "kind": 2,
        "importPath": "src.streamlit.src.clustering_functions",
        "description": "src.streamlit.src.clustering_functions",
        "peekOfCode": "def clusters_factors_charts(df, cluster):\n    if cluster >= 0:\n        query = f'cluster=={cluster}'\n        df = df.query(query)[['cluster', 'age_range', 'risk_factors', 'gender']]\n    else:\n        df = df[['cluster', 'age_range', 'risk_factors', 'gender']]\n    fig, (ax1, ax2, ax3) = plt.subplots(nrows=1, ncols=3, figsize=(18, 6))\n    sns.countplot(x='cluster', hue='risk_factors', data=df, ax=ax1)\n    sns.countplot(x='cluster', hue='age_range', data=df, ax=ax2)\n    sns.countplot(x='cluster', hue='gender', data=df, ax=ax3)",
        "detail": "src.streamlit.src.clustering_functions",
        "documentation": {}
    },
    {
        "label": "eda_cluster",
        "kind": 2,
        "importPath": "src.streamlit.src.clustering_functions",
        "description": "src.streamlit.src.clustering_functions",
        "peekOfCode": "def eda_cluster(df, cluster):      \n    query = f'cluster=={cluster}'\n    df_table = df.query(query)[['age_range',\n                                'obesity_bmi_txt', 'obesity_cc_txt',  \n                                'obesity_rcc_txt', 'obesity_ict_txt', \n                                'risk_factors', 'obesity', 'cluster']]\n    if df_table.obesity.isnull().any():\n        index_cols = ['age_range',\n                        'obesity_bmi_txt', 'obesity_cc_txt',  \n                        'obesity_rcc_txt', 'obesity_ict_txt', ",
        "detail": "src.streamlit.src.clustering_functions",
        "documentation": {}
    },
    {
        "label": "divide_by_gender",
        "kind": 2,
        "importPath": "src.streamlit.src.eda_functions",
        "description": "src.streamlit.src.eda_functions",
        "peekOfCode": "def divide_by_gender(df, val):\n    query = f\"gender == '{val}'\"\n    df = df.query(query)\n    return df\ndef correlation(df):\n    colormap = sns.color_palette('Oranges')\n    corr_df = df.corr(method='pearson', numeric_only=True)\n    fig, ax = plt.subplots(figsize=(12, 8))\n    sns.heatmap(corr_df, annot=True, cmap=colormap)\n    ax.set_title('Matriz de Correlación', fontsize=14, weight='bold')   ",
        "detail": "src.streamlit.src.eda_functions",
        "documentation": {}
    },
    {
        "label": "correlation",
        "kind": 2,
        "importPath": "src.streamlit.src.eda_functions",
        "description": "src.streamlit.src.eda_functions",
        "peekOfCode": "def correlation(df):\n    colormap = sns.color_palette('Oranges')\n    corr_df = df.corr(method='pearson', numeric_only=True)\n    fig, ax = plt.subplots(figsize=(12, 8))\n    sns.heatmap(corr_df, annot=True, cmap=colormap)\n    ax.set_title('Matriz de Correlación', fontsize=14, weight='bold')   \n    return fig\ndef bmi_char(df, df_eda_f, df_eda_m):\n    x = 'count(*):Q'\n    y = 'age_range:O'",
        "detail": "src.streamlit.src.eda_functions",
        "documentation": {}
    },
    {
        "label": "bmi_char",
        "kind": 2,
        "importPath": "src.streamlit.src.eda_functions",
        "description": "src.streamlit.src.eda_functions",
        "peekOfCode": "def bmi_char(df, df_eda_f, df_eda_m):\n    x = 'count(*):Q'\n    y = 'age_range:O'\n    detail = 'obesity_bmi_txt:N'\n    title='Cantidad de Individuos según su rango de edad y grado de Obesidad según su IMC'\n    title_f='Sólo Mujeres'\n    title_m='Sólo Hombres'\n    title_x = 'Total individuos'\n    title_y = 'Rangos de Edad'\n    char_todo = ccf.bars_chart(df, x, y, detail, title, title_x, title_y)",
        "detail": "src.streamlit.src.eda_functions",
        "documentation": {}
    },
    {
        "label": "ict_char",
        "kind": 2,
        "importPath": "src.streamlit.src.eda_functions",
        "description": "src.streamlit.src.eda_functions",
        "peekOfCode": "def ict_char(df, df_eda_f, df_eda_m):\n    x = 'count(*):Q'\n    y = 'age_range:O'\n    detail = 'obesity_ict_txt:N'\n    title='Cantidad de Individuos según su rango de edad y grado de Obesidad según su ICT'\n    title_f='Sólo Mujeres'\n    title_m='Sólo Hombres'\n    title_x = 'Total individuos'\n    title_y = 'Rangos de Edad'\n    char_todo = ccf.bars_chart(df, x, y, detail, title, title_x, title_y)",
        "detail": "src.streamlit.src.eda_functions",
        "documentation": {}
    },
    {
        "label": "rcc_char",
        "kind": 2,
        "importPath": "src.streamlit.src.eda_functions",
        "description": "src.streamlit.src.eda_functions",
        "peekOfCode": "def rcc_char(df, df_eda_f, df_eda_m):\n    x = 'count(*):Q'\n    y = 'age_range:O'\n    detail = 'obesity_rcc_txt:N'\n    title='Cantidad de Individuos según su rango de edad y riesgo de Obesidad según su RCC'\n    title_f='Sólo Mujeres'\n    title_m='Sólo Hombres'\n    title_x = 'Total individuos'\n    title_y = 'Rangos de Edad'\n    char_todo = ccf.bars_chart(df, x, y, detail, title, title_x, title_y)",
        "detail": "src.streamlit.src.eda_functions",
        "documentation": {}
    },
    {
        "label": "cc_char",
        "kind": 2,
        "importPath": "src.streamlit.src.eda_functions",
        "description": "src.streamlit.src.eda_functions",
        "peekOfCode": "def cc_char(df, df_eda_f, df_eda_m):\n    x = 'count(*):Q'\n    y = 'age_range:O'\n    detail = 'obesity_cc_txt:N'\n    title='Cantidad de Individuos según su rango de edad y riesgo de Obesidad según su CC'\n    title_f='Sólo Mujeres'\n    title_m='Sólo Hombres'\n    title_x = 'Total individuos'\n    title_y = 'Rangos de Edad'\n    char_todo = ccf.bars_chart(df, x, y, detail, title, title_x, title_y)",
        "detail": "src.streamlit.src.eda_functions",
        "documentation": {}
    },
    {
        "label": "risks_char",
        "kind": 2,
        "importPath": "src.streamlit.src.eda_functions",
        "description": "src.streamlit.src.eda_functions",
        "peekOfCode": "def risks_char(df, df_eda_f, df_eda_m):\n    x = 'count(*):Q'\n    y = 'age_range:O'\n    detail = 'risk_factors:N'\n    title='Cantidad de Individuos según su rango de edad y cantidad de factores de riesgo'\n    title_f='Sólo Mujeres'\n    title_m='Sólo Hombres'\n    title_x = 'Total individuos'\n    title_y = 'Rangos de Edad'\n    char_todo = ccf.bars_chart(df, x, y, detail, title, title_x, title_y)",
        "detail": "src.streamlit.src.eda_functions",
        "documentation": {}
    },
    {
        "label": "data_report",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def data_report(df):\n    # Sacamos los NOMBRES\n    cols = pd.DataFrame(df.columns.values, columns=[\"COL_N\"])\n    # Sacamos los TIPOS\n    types = pd.DataFrame(df.dtypes.values, columns=[\"DATA_TYPE\"])\n    # Sacamos los MISSINGS\n    percent_missing = round(df.isnull().sum() * 100 / len(df), 2)\n    percent_missing_df = pd.DataFrame(percent_missing.values, columns=[\"MISSINGS (%)\"])\n    # Sacamos los VALORES UNICOS\n    unicos = pd.DataFrame(df.nunique().values, columns=[\"UNIQUE_VALUES\"])",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "drop_cols",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def drop_cols(df_, max_cardi=20, max_miss=30):\n    df = df_.copy()\n    delete_col = []\n    for i in df.columns:\n        missings = df[i].isnull().sum() * 100 / len(df)\n        # Elimina por missings\n        if missings >= max_miss:\n            df.drop(i, 1, inplace=True)\n            continue\n        # Elimina por cardinalidad en variables categoricas",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "outliers_quantile",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def outliers_quantile(df, feature, param=1.5):  \n    iqr_ = iqr(df[feature], nan_policy='omit')\n    q1 = np.nanpercentile(df[feature], 25)\n    q3 = np.nanpercentile(df[feature], 75)\n    th1 = q1 - iqr_*param\n    th2 = q3 + iqr_*param\n    return df[(df[feature] >= th1) & (df[feature] <= th2)].reset_index(drop=True)\ndef outlier_meanSd(df, feature, param=3):   \n    media = df[feature].mean()\n    desEst = df[feature].std()",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "outlier_meanSd",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def outlier_meanSd(df, feature, param=3):   \n    media = df[feature].mean()\n    desEst = df[feature].std()\n    th1 = media - desEst*param\n    th2 = media + desEst*param\n    return df[((df[feature] >= th1) & (df[feature] <= th2))  | (df[feature].isnull())].reset_index(drop=True)\ndef plot_tidy_categorical(df, sel_cols, target, file_output=None):\n    \"\"\"\n    Generate bar plots for each categorical variable,\n    grouped by target variable.",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_tidy_categorical",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_tidy_categorical(df, sel_cols, target, file_output=None):\n    \"\"\"\n    Generate bar plots for each categorical variable,\n    grouped by target variable.\n    Parameters:\n    - df: DataFrame, the input dataset\n    - sel_cols: list, categorical variables\n    - target: str, name of the column containing the target variable\n    Returns:\n    - None (displays the plots)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_tidy",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_tidy(df, sel_cols, target,file_output=None):\n    \"\"\"\n    Generate kernel density estimation (KDE) plots for each variable,\n    grouped by target variable.\n    Parameters:\n    - df: DataFrame, the input dataset\n    - sel_cols: list, variables used for clustering\n    - target: str, name of the column containing the target variable\n    Returns:\n    - None (displays the plots)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "reduce_memory_usage",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def reduce_memory_usage(df, verbose=True):\n    numerics = [\"int8\", \"int16\", \"int32\", \"int64\", \"float16\", \"float32\", \"float64\"]\n    start_mem = df.memory_usage().sum() / 1024 ** 2\n    # Excluir las columnas de índice\n    columns_to_exclude = df.index.names if df.index.name else []\n    for col in df.columns:\n        if col in columns_to_exclude:\n            continue\n        col_type = df[col].dtypes\n        if col_type in numerics:",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_kde_histogram_with_stats",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_kde_histogram_with_stats(data, column_name, title, ax=None):\n    # Use provided ax or create a new subplot\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(10, 6))\n    # KDE + Histogram\n    sns.distplot(data[column_name],fit=norm, kde=True, rug=True, ax=ax)\n    ax.set_title(f'KDE + Histogram - {title}')\n    # Verificar si la columna contiene datos numéricos\n    if pd.api.types.is_numeric_dtype(data[column_name].dtype):\n        # Calcular estadísticas solo si la columna contiene datos numéricos",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "box_violin_plot",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def box_violin_plot(data, column, title, ax=None):\n    # Use provided ax or create a new subplot\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(8, 4))\n    # Violin + Boxplot\n    sns.violinplot(data=data, x=column, inner='point', linewidth=0, saturation=0.4, orient='h', ax=ax)\n    sns.boxplot(x=column, data=data, width=0.3, boxprops={'zorder': 2}, ax=ax, orient='h', fliersize=5)\n    # Adjust the plot design\n    ax.set_title(f\"Boxplot + Violin Plot - {title}\")\n    # Get statistics",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "qq_plot",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def qq_plot(data, column_name, title,ax=None):\n    if ax is None:\n        _, ax = plt.subplots(figsize=(8, 4))\n    # Create QQ plot\n    sm.qqplot(data[column_name], line='s', ax=ax)\n    ax.set_title(f\"Quantile-Quantile Plot - {title}\")\n    plt.xlabel(\"Cuantiles teóricos\")\n    plt.ylabel(\"Cuantiles observados\")\ndef plot_distribucion(data, column_name, **kwargs):\n    title = kwargs.get('title', column_name)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_distribucion",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_distribucion(data, column_name, **kwargs):\n    title = kwargs.get('title', column_name)\n    save_png, filename = kwargs.get('save_png', False), kwargs.get('filename', 'tmp.png')\n    # Create subplots with specified width ratios\n    fig, axs = plt.subplots(1, 3, figsize=(15, 6), gridspec_kw={'width_ratios': [2, 2, 1]})\n    # Loop through the plots and functions\n    for i, plot_function in enumerate([plot_kde_histogram_with_stats, box_violin_plot, qq_plot]):\n        plot_function(data, column_name, title, ax=axs[i])\n    # Adjust the layout of the subplots\n    plt.tight_layout()",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "sim_curtosis",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def sim_curtosis(data, column_name):\n    kurtosis_valor = kurtosis(data[column_name])\n    skewness_valor = skew(data[column_name])\n    if kurtosis_valor > 3:\n        kurtosis_=\"La distribución es leptocúrtica, lo que sugiere colas pesadas y picos agudos.\"\n    elif kurtosis_valor < 3:\n        kurtosis_=\"La distribución es platicúrtica, lo que sugiere colas ligeras y un pico achatado.\"\n    else:\n        kurtosis_=\"La distribución es mesocúrtica, similar a una distribución normal.\"\n    if skewness_valor > 0:",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_horizontal_catplot",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_horizontal_catplot(df, catcols, diccionario_columnas=None, diccionario_valores=None,\n                            save_png=False, filename='tmp.png'):\n    \"\"\"\n    Genera gráficos Seaborn para la frecuencia de valores únicos en las columnas categóricas del DataFrame.\n    Los gráficos se organizan en filas y las categorías se ordenan por porcentaje descendente.\n    El número de valores NaN o nulos se muestra en el título de cada gráfico.\n    Parameters:\n    - df: DataFrame de pandas\n    - catcols: Lista de columnas categóricas\n    - diccionario_columnas: Diccionario para decodificar nombres de columnas (opcional)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_analysis",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_analysis(data, target, col):\n    col_mean = []\n    for each in data[target].unique():\n        x = data[data[target] == each]\n        mean = x[col].mean()\n        col_mean.append(mean)\n    plt.figure(figsize=(8,6))\n    plt.subplot(2,2,1)\n    plt.hist(data[col], color=\"lightgreen\")\n    plt.xlabel(col)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "sqrt_transform",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def sqrt_transform(X):\n    return np.sqrt(X)\ndef log_transform(X):\n    return np.log1p(X)\ndef classify_distributions(df, threshold=0.05):\n    \"\"\"\n    Clasifica las distribuciones de las columnas numéricas del DataFrame en una de las siguientes categorías:\n    - 'normal': si la distribución se ajusta a una distribución normal según el test de Shapiro-Wilk.\n    - 'positive_increasing': si la distribución es estrictamente creciente positiva.\n    - 'positive_decreasing': si la distribución es estrictamente decreciente positiva.",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "log_transform",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def log_transform(X):\n    return np.log1p(X)\ndef classify_distributions(df, threshold=0.05):\n    \"\"\"\n    Clasifica las distribuciones de las columnas numéricas del DataFrame en una de las siguientes categorías:\n    - 'normal': si la distribución se ajusta a una distribución normal según el test de Shapiro-Wilk.\n    - 'positive_increasing': si la distribución es estrictamente creciente positiva.\n    - 'positive_decreasing': si la distribución es estrictamente decreciente positiva.\n    - 'rectangular': si la distribución es rectangular.\n    - 'skewed_left': si la distribución tiene sesgo a la izquierda.",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "classify_distributions",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def classify_distributions(df, threshold=0.05):\n    \"\"\"\n    Clasifica las distribuciones de las columnas numéricas del DataFrame en una de las siguientes categorías:\n    - 'normal': si la distribución se ajusta a una distribución normal según el test de Shapiro-Wilk.\n    - 'positive_increasing': si la distribución es estrictamente creciente positiva.\n    - 'positive_decreasing': si la distribución es estrictamente decreciente positiva.\n    - 'rectangular': si la distribución es rectangular.\n    - 'skewed_left': si la distribución tiene sesgo a la izquierda.\n    - 'skewed_right': si la distribución tiene sesgo a la derecha.\n    - 'bimodal': si la distribución tiene dos modas.",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "selvars_boruta",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def selvars_boruta(data,ytarget,isclass=True,n_trials=100):\n    Feature_Selector = BorutaShap(importance_measure='shap',\n                                classification=isclass)\n    Feature_Selector.fit(X=data, y=ytarget, n_trials=n_trials, random_state=0)\n    Feature_Selector.TentativeRoughFix()\n    Feature_Selector.plot(X_size=8, figsize=(20,8),\n                y_scale='log', which_features='all')\n    selvars=sorted(list(Feature_Selector.Subset().columns))\n    return selvars\nimport seaborn as sns",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_confusion_matrix",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_confusion_matrix(true_labels, predicted_labels):\n    \"\"\"\n    Plot a confusion matrix using true labels and predicted labels.\n    Parameters:\n    true_labels (array-like): True labels.\n    predicted_labels (array-like): Predicted labels.\n    \"\"\"\n    # Calculate the confusion matrix\n    conf_matrix = confusion_matrix(true_labels, predicted_labels)\n    # Create a heatmap using seaborn",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "cross_validation_with_confusion_matrix",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def cross_validation_with_confusion_matrix(estimator, X, y, nsplits=10):\n    cv = StratifiedKFold(n_splits=nsplits)\n    # Perform cross-validation\n    predicted = cross_val_predict(estimator, X, y, cv=cv)\n    # Calculate confusion matrix and classification report for each fold\n    for i, (train_idx, test_idx) in enumerate(cv.split(X, y)):\n        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]\n        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]\n        # Fit the estimator on training data\n        estimator.fit(X_train, y_train)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "plot_roc_curve",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def plot_roc_curve(model, X_val, y_val):\n    # Predecir las probabilidades de las clases positivas\n    y_prob = model.predict_proba(X_val)[:, 1]\n    # Calcular la tasa de verdaderos positivos (TPR) y la tasa de falsos positivos (FPR)\n    fpr, tpr, thresholds = roc_curve(y_val, y_prob)\n    # Calcular el área bajo la curva ROC (AUC)\n    auc = roc_auc_score(y_val, y_prob)\n    # Plotear la curva ROC\n    plt.figure(figsize=(8, 6))\n    plt.plot(fpr, tpr, label=f'AUC = {auc:.2f}')",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "generate_roc_auc",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def generate_roc_auc(estimator, X_train, y_train, X_val, y_val):\n    \"\"\"\n    Generate ROC curve and calculate AUC using one-vs-all technique.\n    Parameters:\n    estimator: scikit-learn estimator object\n        The classifier or regressor to use.\n    X_train: array-like, shape (n_samples, n_features)\n        The input samples for training.\n    y_train: array-like, shape (n_samples,)\n        The target values for training.",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "hyperparameter_tuning",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def hyperparameter_tuning(models, X, y, scoring='accuracy'):\n    # Almacena los resultados en un DataFrame\n    results = []\n    # Loop sobre los modelos con tqdm para mostrar una barra de progreso\n    for model_name, config in tqdm(models.items(), desc=\"Hyperparameter Tuning\"):\n        model = RandomizedSearchCV(config[\"model\"], config[\"params\"], n_iter=50, cv=5, scoring=scoring,\n                                   random_state=42)\n        model.fit(X, y)  # Ajusta el modelo con los datos de entrenamiento\n        best_params = model.best_params_\n        best_score = model.best_score_",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "perform_cross_validation",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def perform_cross_validation(models, x_train, y_train, n_splits=8, random_state=42, metric='accuracy'):\n    kfold = StratifiedKFold(n_splits=n_splits, shuffle=True, random_state=random_state)\n    cv_results = []\n    for name, model in models.items():\n        cv_scores = cross_val_score(model, x_train, y_train, scoring=metric, cv=kfold, n_jobs=-1)\n        cv_results.append(np.mean(cv_scores))\n    cv_df = pd.DataFrame({\"CrossVal_Score_Means\": cv_results, \"Algorithm\": list(models.keys())})\n    plt.figure(figsize=(10, 7))\n    g = sns.barplot(x=\"CrossVal_Score_Means\", y=\"Algorithm\", data=cv_df, orient=\"h\", palette='cool', \n                    edgecolor=\"black\", linewidth=1)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "test_distribution_cv",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def test_distribution_cv(dataframe, perfrac=0.01, columns=None, n_trials=10):\n    sample = X_train.sample(frac=perfrac)\n    kf = KFold(n_splits=n_trials, shuffle=True, random_state=42)\n    results = []\n    if columns is None:\n        columns = dataframe.columns\n    for column_name in columns:\n        equal_distributions = 0\n        for train_index, test_index in kf.split(dataframe):\n            train_data = dataframe.iloc[train_index]",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_input_columns_pipeline",
        "kind": 2,
        "importPath": "src.utils.utils",
        "description": "src.utils.utils",
        "peekOfCode": "def get_input_columns_pipeline(pipeline):\n    input_columns = []\n    column_transformer=pipeline.named_steps['preprocessor']   \n    # Iterar sobre las transformaciones dentro del ColumnTransformer\n    for _, _, columns in column_transformer.transformers_:\n        # Si el transformer es 'passthrough', agregar las columnas originales\n        if columns == 'passthrough':\n            input_columns.extend(columns)\n        else:\n            input_columns.extend(columns)",
        "detail": "src.utils.utils",
        "documentation": {}
    },
    {
        "label": "open_terminal",
        "kind": 2,
        "importPath": "src.open",
        "description": "src.open",
        "peekOfCode": "def open_terminal(comando):\n    subprocess.run([\"gnome-terminal -e \" + comando], shell=True, check=True)\ndef run_command(comando):\n    subprocess.call([comando], shell=True)\nif __name__ == \"__main__\":\n    # Abre una terminal y ejecuta el comando ls\n    open_terminal(\"sh run-app.sh\")\n    # Abre otra terminal y ejecuta el comando ps\n    open_terminal(\"ls\")\n    # Ejecuta el comando date en la terminal actual",
        "detail": "src.open",
        "documentation": {}
    },
    {
        "label": "run_command",
        "kind": 2,
        "importPath": "src.open",
        "description": "src.open",
        "peekOfCode": "def run_command(comando):\n    subprocess.call([comando], shell=True)\nif __name__ == \"__main__\":\n    # Abre una terminal y ejecuta el comando ls\n    open_terminal(\"sh run-app.sh\")\n    # Abre otra terminal y ejecuta el comando ps\n    open_terminal(\"ls\")\n    # Ejecuta el comando date en la terminal actual\n    run_command(\"date\")",
        "detail": "src.open",
        "documentation": {}
    }
]